// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cdm_message.proto

package protogo

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type CDMType int32

const (
	CDMType_CDM_TYPE_UNDEFINED                         CDMType = 0
	CDMType_CDM_TYPE_TX_REQUEST                        CDMType = 1
	CDMType_CDM_TYPE_TX_RESPONSE                       CDMType = 2
	CDMType_CDM_TYPE_GET_STATE                         CDMType = 3
	CDMType_CDM_TYPE_GET_STATE_RESPONSE                CDMType = 4
	CDMType_CDM_TYPE_GET_BYTECODE                      CDMType = 5
	CDMType_CDM_TYPE_GET_BYTECODE_RESPONSE             CDMType = 6
	CDMType_CDM_TYPE_CREATE_KV_ITERATOR                CDMType = 7
	CDMType_CDM_TYPE_CREATE_KV_ITERATOR_RESPONSE       CDMType = 8
	CDMType_CDM_TYPE_CONSUME_KV_ITERATOR               CDMType = 9
	CDMType_CDM_TYPE_CONSUME_KV_ITERATOR_RESPONSE      CDMType = 10
	CDMType_CDM_TYPE_CREATE_KEY_HISTORY_ITER           CDMType = 11
	CDMType_CDM_TYPE_CREATE_KEY_HISTORY_TER_RESPONSE   CDMType = 12
	CDMType_CDM_TYPE_CONSUME_KEY_HISTORY_ITER          CDMType = 13
	CDMType_CDM_TYPE_CONSUME_KEY_HISTORY_ITER_RESPONSE CDMType = 14
	CDMType_CDM_TYPE_GET_SENDER_ADDRESS                CDMType = 15
	CDMType_CDM_TYPE_GET_SENDER_ADDRESS_RESPONSE       CDMType = 16
	CDMType_CDM_TYPE_GET_CONTRACT_NAME                 CDMType = 17
	CDMType_CDM_TYPE_GET_CONTRACT_NAME_RESPONSE        CDMType = 18
	CDMType_CDM_TYPE_GET_BATCH_STATE                   CDMType = 19
	CDMType_CDM_TYPE_GET_BATCH_STATE_RESPONSE          CDMType = 20
)

var CDMType_name = map[int32]string{
	0:  "CDM_TYPE_UNDEFINED",
	1:  "CDM_TYPE_TX_REQUEST",
	2:  "CDM_TYPE_TX_RESPONSE",
	3:  "CDM_TYPE_GET_STATE",
	4:  "CDM_TYPE_GET_STATE_RESPONSE",
	5:  "CDM_TYPE_GET_BYTECODE",
	6:  "CDM_TYPE_GET_BYTECODE_RESPONSE",
	7:  "CDM_TYPE_CREATE_KV_ITERATOR",
	8:  "CDM_TYPE_CREATE_KV_ITERATOR_RESPONSE",
	9:  "CDM_TYPE_CONSUME_KV_ITERATOR",
	10: "CDM_TYPE_CONSUME_KV_ITERATOR_RESPONSE",
	11: "CDM_TYPE_CREATE_KEY_HISTORY_ITER",
	12: "CDM_TYPE_CREATE_KEY_HISTORY_TER_RESPONSE",
	13: "CDM_TYPE_CONSUME_KEY_HISTORY_ITER",
	14: "CDM_TYPE_CONSUME_KEY_HISTORY_ITER_RESPONSE",
	15: "CDM_TYPE_GET_SENDER_ADDRESS",
	16: "CDM_TYPE_GET_SENDER_ADDRESS_RESPONSE",
	17: "CDM_TYPE_GET_CONTRACT_NAME",
	18: "CDM_TYPE_GET_CONTRACT_NAME_RESPONSE",
	19: "CDM_TYPE_GET_BATCH_STATE",
	20: "CDM_TYPE_GET_BATCH_STATE_RESPONSE",
}

var CDMType_value = map[string]int32{
	"CDM_TYPE_UNDEFINED":                         0,
	"CDM_TYPE_TX_REQUEST":                        1,
	"CDM_TYPE_TX_RESPONSE":                       2,
	"CDM_TYPE_GET_STATE":                         3,
	"CDM_TYPE_GET_STATE_RESPONSE":                4,
	"CDM_TYPE_GET_BYTECODE":                      5,
	"CDM_TYPE_GET_BYTECODE_RESPONSE":             6,
	"CDM_TYPE_CREATE_KV_ITERATOR":                7,
	"CDM_TYPE_CREATE_KV_ITERATOR_RESPONSE":       8,
	"CDM_TYPE_CONSUME_KV_ITERATOR":               9,
	"CDM_TYPE_CONSUME_KV_ITERATOR_RESPONSE":      10,
	"CDM_TYPE_CREATE_KEY_HISTORY_ITER":           11,
	"CDM_TYPE_CREATE_KEY_HISTORY_TER_RESPONSE":   12,
	"CDM_TYPE_CONSUME_KEY_HISTORY_ITER":          13,
	"CDM_TYPE_CONSUME_KEY_HISTORY_ITER_RESPONSE": 14,
	"CDM_TYPE_GET_SENDER_ADDRESS":                15,
	"CDM_TYPE_GET_SENDER_ADDRESS_RESPONSE":       16,
	"CDM_TYPE_GET_CONTRACT_NAME":                 17,
	"CDM_TYPE_GET_CONTRACT_NAME_RESPONSE":        18,
	"CDM_TYPE_GET_BATCH_STATE":                   19,
	"CDM_TYPE_GET_BATCH_STATE_RESPONSE":          20,
}

func (x CDMType) String() string {
	return proto.EnumName(CDMType_name, int32(x))
}

func (CDMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{0}
}

type ContractResultCode int32

const (
	ContractResultCode_OK   ContractResultCode = 0
	ContractResultCode_FAIL ContractResultCode = 1
)

var ContractResultCode_name = map[int32]string{
	0: "OK",
	1: "FAIL",
}

var ContractResultCode_value = map[string]int32{
	"OK":   0,
	"FAIL": 1,
}

func (x ContractResultCode) String() string {
	return proto.EnumName(ContractResultCode_name, int32(x))
}

func (ContractResultCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{1}
}

type ProcessState int32

const (
	ProcessState_PROCESS_STATE_CREATED        ProcessState = 0
	ProcessState_PROCESS_STATE_RUNNING        ProcessState = 1
	ProcessState_PROCESS_STATE_EXPIRE         ProcessState = 2
	ProcessState_PROCESS_STATE_TX_TIMEOUT     ProcessState = 3
	ProcessState_PROCESS_STATE_CROSS_FINISHED ProcessState = 4
	ProcessState_PROCESS_STATE_CROSS_FAIL     ProcessState = 5
)

var ProcessState_name = map[int32]string{
	0: "PROCESS_STATE_CREATED",
	1: "PROCESS_STATE_RUNNING",
	2: "PROCESS_STATE_EXPIRE",
	3: "PROCESS_STATE_TX_TIMEOUT",
	4: "PROCESS_STATE_CROSS_FINISHED",
	5: "PROCESS_STATE_CROSS_FAIL",
}

var ProcessState_value = map[string]int32{
	"PROCESS_STATE_CREATED":        0,
	"PROCESS_STATE_RUNNING":        1,
	"PROCESS_STATE_EXPIRE":         2,
	"PROCESS_STATE_TX_TIMEOUT":     3,
	"PROCESS_STATE_CROSS_FINISHED": 4,
	"PROCESS_STATE_CROSS_FAIL":     5,
}

func (x ProcessState) String() string {
	return proto.EnumName(ProcessState_name, int32(x))
}

func (ProcessState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{2}
}

//CMMessage means message between chainmaker and docker manager
type CDMMessage struct {
	TxId       string      `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Type       CDMType     `protobuf:"varint,2,opt,name=type,proto3,enum=proto.CDMType" json:"type,omitempty"`
	ResultCode int32       `protobuf:"varint,3,opt,name=result_code,json=resultCode,proto3" json:"result_code,omitempty"`
	Payload    []byte      `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	Message    string      `protobuf:"bytes,5,opt,name=message,proto3" json:"message,omitempty"`
	TxRequest  *TxRequest  `protobuf:"bytes,6,opt,name=txRequest,proto3" json:"txRequest,omitempty"`
	TxResponse *TxResponse `protobuf:"bytes,7,opt,name=txResponse,proto3" json:"txResponse,omitempty"`
	ChainId    string      `protobuf:"bytes,8,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *CDMMessage) Reset()         { *m = CDMMessage{} }
func (m *CDMMessage) String() string { return proto.CompactTextString(m) }
func (*CDMMessage) ProtoMessage()    {}
func (*CDMMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{0}
}
func (m *CDMMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CDMMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CDMMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CDMMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CDMMessage.Merge(m, src)
}
func (m *CDMMessage) XXX_Size() int {
	return m.Size()
}
func (m *CDMMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_CDMMessage.DiscardUnknown(m)
}

var xxx_messageInfo_CDMMessage proto.InternalMessageInfo

func (m *CDMMessage) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *CDMMessage) GetType() CDMType {
	if m != nil {
		return m.Type
	}
	return CDMType_CDM_TYPE_UNDEFINED
}

func (m *CDMMessage) GetResultCode() int32 {
	if m != nil {
		return m.ResultCode
	}
	return 0
}

func (m *CDMMessage) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *CDMMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *CDMMessage) GetTxRequest() *TxRequest {
	if m != nil {
		return m.TxRequest
	}
	return nil
}

func (m *CDMMessage) GetTxResponse() *TxResponse {
	if m != nil {
		return m.TxResponse
	}
	return nil
}

func (m *CDMMessage) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

// TX_REQUEST
type TxRequest struct {
	TxId            string            `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	ContractName    string            `protobuf:"bytes,2,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractVersion string            `protobuf:"bytes,3,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	Method          string            `protobuf:"bytes,4,opt,name=method,proto3" json:"method,omitempty"`
	Parameters      map[string][]byte `protobuf:"bytes,5,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// cross contract in use
	TxContext *TxContext `protobuf:"bytes,6,opt,name=tx_context,json=txContext,proto3" json:"tx_context,omitempty"`
	ChainId   string     `protobuf:"bytes,7,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TxRequest) Reset()         { *m = TxRequest{} }
func (m *TxRequest) String() string { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()    {}
func (*TxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{1}
}
func (m *TxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest.Merge(m, src)
}
func (m *TxRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest proto.InternalMessageInfo

func (m *TxRequest) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxRequest) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *TxRequest) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *TxRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *TxRequest) GetParameters() map[string][]byte {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *TxRequest) GetTxContext() *TxContext {
	if m != nil {
		return m.TxContext
	}
	return nil
}

func (m *TxRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type TxContext struct {
	CurrentHeight       uint32            `protobuf:"varint,1,opt,name=current_height,json=currentHeight,proto3" json:"current_height,omitempty"`
	WriteMap            map[string][]byte `protobuf:"bytes,2,rep,name=write_map,json=writeMap,proto3" json:"write_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadMap             map[string][]byte `protobuf:"bytes,3,rep,name=read_map,json=readMap,proto3" json:"read_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OriginalProcessName string            `protobuf:"bytes,4,opt,name=original_process_name,json=originalProcessName,proto3" json:"original_process_name,omitempty"`
}

func (m *TxContext) Reset()         { *m = TxContext{} }
func (m *TxContext) String() string { return proto.CompactTextString(m) }
func (*TxContext) ProtoMessage()    {}
func (*TxContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{2}
}
func (m *TxContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxContext.Merge(m, src)
}
func (m *TxContext) XXX_Size() int {
	return m.Size()
}
func (m *TxContext) XXX_DiscardUnknown() {
	xxx_messageInfo_TxContext.DiscardUnknown(m)
}

var xxx_messageInfo_TxContext proto.InternalMessageInfo

func (m *TxContext) GetCurrentHeight() uint32 {
	if m != nil {
		return m.CurrentHeight
	}
	return 0
}

func (m *TxContext) GetWriteMap() map[string][]byte {
	if m != nil {
		return m.WriteMap
	}
	return nil
}

func (m *TxContext) GetReadMap() map[string][]byte {
	if m != nil {
		return m.ReadMap
	}
	return nil
}

func (m *TxContext) GetOriginalProcessName() string {
	if m != nil {
		return m.OriginalProcessName
	}
	return ""
}

// TX_RESPONSE
type TxResponse struct {
	TxId     string                 `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Code     ContractResultCode     `protobuf:"varint,2,opt,name=code,proto3,enum=proto.ContractResultCode" json:"code,omitempty"`
	Result   []byte                 `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	Message  string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	WriteMap map[string][]byte      `protobuf:"bytes,5,rep,name=write_map,json=writeMap,proto3" json:"write_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Events   []*DockerContractEvent `protobuf:"bytes,6,rep,name=events,proto3" json:"events,omitempty"`
	ReadMap  map[string][]byte      `protobuf:"bytes,7,rep,name=read_map,json=readMap,proto3" json:"read_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ChainId  string                 `protobuf:"bytes,8,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TxResponse) Reset()         { *m = TxResponse{} }
func (m *TxResponse) String() string { return proto.CompactTextString(m) }
func (*TxResponse) ProtoMessage()    {}
func (*TxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{3}
}
func (m *TxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxResponse.Merge(m, src)
}
func (m *TxResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxResponse proto.InternalMessageInfo

func (m *TxResponse) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxResponse) GetCode() ContractResultCode {
	if m != nil {
		return m.Code
	}
	return ContractResultCode_OK
}

func (m *TxResponse) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TxResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TxResponse) GetWriteMap() map[string][]byte {
	if m != nil {
		return m.WriteMap
	}
	return nil
}

func (m *TxResponse) GetEvents() []*DockerContractEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *TxResponse) GetReadMap() map[string][]byte {
	if m != nil {
		return m.ReadMap
	}
	return nil
}

func (m *TxResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type DockerContractEvent struct {
	// Event topic
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// Event contract name
	ContractName string `protobuf:"bytes,2,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// Event contract version
	ContractVersion string `protobuf:"bytes,3,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	// Event payload
	Data []string `protobuf:"bytes,4,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *DockerContractEvent) Reset()         { *m = DockerContractEvent{} }
func (m *DockerContractEvent) String() string { return proto.CompactTextString(m) }
func (*DockerContractEvent) ProtoMessage()    {}
func (*DockerContractEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_797a9ac5b2994f84, []int{4}
}
func (m *DockerContractEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DockerContractEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DockerContractEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DockerContractEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DockerContractEvent.Merge(m, src)
}
func (m *DockerContractEvent) XXX_Size() int {
	return m.Size()
}
func (m *DockerContractEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DockerContractEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DockerContractEvent proto.InternalMessageInfo

func (m *DockerContractEvent) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *DockerContractEvent) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *DockerContractEvent) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *DockerContractEvent) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.CDMType", CDMType_name, CDMType_value)
	proto.RegisterEnum("proto.ContractResultCode", ContractResultCode_name, ContractResultCode_value)
	proto.RegisterEnum("proto.ProcessState", ProcessState_name, ProcessState_value)
	proto.RegisterType((*CDMMessage)(nil), "proto.CDMMessage")
	proto.RegisterType((*TxRequest)(nil), "proto.TxRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxRequest.ParametersEntry")
	proto.RegisterType((*TxContext)(nil), "proto.TxContext")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxContext.ReadMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxContext.WriteMapEntry")
	proto.RegisterType((*TxResponse)(nil), "proto.TxResponse")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxResponse.ReadMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxResponse.WriteMapEntry")
	proto.RegisterType((*DockerContractEvent)(nil), "proto.DockerContractEvent")
}

func init() { proto.RegisterFile("cdm_message.proto", fileDescriptor_797a9ac5b2994f84) }

var fileDescriptor_797a9ac5b2994f84 = []byte{
	// 1117 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x56, 0x4f, 0x73, 0xdb, 0x54,
	0x10, 0xb7, 0xfc, 0xdf, 0x1b, 0x27, 0x51, 0x5e, 0x92, 0xa2, 0x98, 0xe0, 0x18, 0xb7, 0x01, 0x37,
	0x43, 0x6c, 0x30, 0x97, 0xd0, 0x96, 0x19, 0x5c, 0xe9, 0xa5, 0xf1, 0x14, 0xcb, 0xe6, 0x49, 0x29,
	0x09, 0x17, 0x8d, 0x6a, 0xbf, 0x71, 0x3c, 0x89, 0x2c, 0x21, 0x29, 0x69, 0xf2, 0x29, 0xe0, 0xc8,
	0x87, 0xe1, 0xc6, 0x85, 0x63, 0x2f, 0x30, 0x1c, 0x99, 0xe4, 0xc2, 0xc7, 0x60, 0xa4, 0x27, 0x5b,
	0x96, 0x95, 0x84, 0xe9, 0x0c, 0x33, 0x3d, 0x59, 0xbb, 0xfb, 0xdb, 0xdf, 0xbe, 0xf7, 0xdb, 0xdd,
	0x37, 0x86, 0x95, 0xfe, 0xc0, 0xd0, 0x0c, 0xea, 0x38, 0xfa, 0x90, 0xd6, 0x2d, 0xdb, 0x74, 0x4d,
	0x94, 0xf1, 0x7f, 0xaa, 0xbf, 0x24, 0x01, 0x44, 0xa9, 0xd3, 0x61, 0x31, 0xb4, 0x0a, 0x19, 0xf7,
	0x52, 0x1b, 0x0d, 0x04, 0xae, 0xc2, 0xd5, 0x0a, 0x24, 0xed, 0x5e, 0xb6, 0x07, 0xa8, 0x0a, 0x69,
	0xf7, 0xca, 0xa2, 0x42, 0xb2, 0xc2, 0xd5, 0x96, 0x9a, 0x4b, 0x8c, 0xa0, 0x2e, 0x4a, 0x1d, 0xf5,
	0xca, 0xa2, 0xc4, 0x8f, 0xa1, 0x2d, 0x58, 0xb0, 0xa9, 0x73, 0x7e, 0xe6, 0x6a, 0x7d, 0x73, 0x40,
	0x85, 0x54, 0x85, 0xab, 0x65, 0x08, 0x30, 0x97, 0x68, 0x0e, 0x28, 0x12, 0x20, 0x67, 0xe9, 0x57,
	0x67, 0xa6, 0x3e, 0x10, 0xd2, 0x15, 0xae, 0x56, 0x24, 0x13, 0xd3, 0x8b, 0x04, 0x47, 0x13, 0x32,
	0x7e, 0xd5, 0x89, 0x89, 0xea, 0x50, 0x70, 0x2f, 0x09, 0xfd, 0xf1, 0x9c, 0x3a, 0xae, 0x90, 0xad,
	0x70, 0xb5, 0x85, 0x26, 0x1f, 0x54, 0x57, 0x27, 0x7e, 0x12, 0x42, 0xd0, 0x17, 0x00, 0x9e, 0xe1,
	0x58, 0xe6, 0xd8, 0xa1, 0x42, 0xce, 0x4f, 0x58, 0x99, 0x49, 0x60, 0x01, 0x32, 0x03, 0x42, 0x1b,
	0x90, 0xef, 0x9f, 0xe8, 0xa3, 0xb1, 0x77, 0xe7, 0x3c, 0xab, 0xee, 0xdb, 0xed, 0x41, 0xf5, 0x8f,
	0x24, 0x14, 0xa6, 0x65, 0x6e, 0x57, 0xe6, 0x21, 0x2c, 0xf6, 0xcd, 0xb1, 0x6b, 0xeb, 0x7d, 0x57,
	0x1b, 0xeb, 0x06, 0x93, 0xa8, 0x40, 0x8a, 0x13, 0xa7, 0xac, 0x1b, 0x14, 0x3d, 0x06, 0x7e, 0x0a,
	0xba, 0xa0, 0xb6, 0x33, 0x32, 0xc7, 0xbe, 0x3e, 0x05, 0xb2, 0x3c, 0xf1, 0xbf, 0x62, 0x6e, 0xf4,
	0x00, 0xb2, 0x06, 0x75, 0x4f, 0x4c, 0xa6, 0x51, 0x81, 0x04, 0x16, 0xfa, 0x06, 0xc0, 0xd2, 0x6d,
	0xdd, 0xa0, 0x2e, 0xb5, 0x1d, 0x21, 0x53, 0x49, 0xd5, 0x16, 0x9a, 0x95, 0x79, 0x25, 0xea, 0xbd,
	0x29, 0x04, 0x8f, 0x5d, 0xfb, 0x8a, 0xcc, 0xe4, 0xa0, 0x86, 0x27, 0x8d, 0xe6, 0xd5, 0xa3, 0x97,
	0x71, 0x2d, 0x45, 0xe6, 0xf7, 0xb4, 0x0c, 0x3e, 0x23, 0xc2, 0xe4, 0x22, 0xc2, 0x94, 0xbe, 0x86,
	0xe5, 0xb9, 0x52, 0x88, 0x87, 0xd4, 0x29, 0xbd, 0x0a, 0xb4, 0xf1, 0x3e, 0xd1, 0x1a, 0x64, 0x2e,
	0xf4, 0xb3, 0x73, 0x26, 0x49, 0x91, 0x30, 0xe3, 0x49, 0x72, 0x8f, 0xab, 0xfe, 0xe9, 0xeb, 0x3a,
	0xa9, 0xb3, 0x0d, 0x4b, 0xfd, 0x73, 0xdb, 0xa6, 0x63, 0x57, 0x3b, 0xa1, 0xa3, 0xe1, 0x89, 0xeb,
	0x93, 0x2c, 0x92, 0xc5, 0xc0, 0x7b, 0xe0, 0x3b, 0xd1, 0x53, 0x28, 0xbc, 0xb1, 0x47, 0x2e, 0xd5,
	0x0c, 0xdd, 0x12, 0x92, 0xbe, 0x00, 0xe5, 0xf9, 0xe3, 0xd7, 0xbf, 0xf7, 0x10, 0x1d, 0xdd, 0x62,
	0xd7, 0xcf, 0xbf, 0x09, 0x4c, 0xb4, 0x07, 0x79, 0x9b, 0xea, 0x03, 0x3f, 0x37, 0xe5, 0xe7, 0x7e,
	0x14, 0xcb, 0x25, 0x54, 0x1f, 0x4c, 0x53, 0x73, 0x36, 0xb3, 0x50, 0x13, 0xd6, 0x4d, 0x7b, 0x34,
	0x1c, 0x8d, 0xf5, 0x33, 0xcd, 0xb2, 0xcd, 0x3e, 0x75, 0x1c, 0xd6, 0x68, 0xd6, 0x9f, 0xd5, 0x49,
	0xb0, 0xc7, 0x62, 0x5e, 0xbf, 0x4b, 0x4f, 0x61, 0x31, 0x72, 0x90, 0x77, 0x11, 0xa7, 0xf4, 0x04,
	0x8a, 0xb3, 0x27, 0x79, 0x27, 0x61, 0x7f, 0x4b, 0x01, 0x84, 0x63, 0x7e, 0xfb, 0xc4, 0xee, 0x42,
	0xda, 0x5f, 0x50, 0xb6, 0xcb, 0x1b, 0x93, 0x5d, 0x0e, 0xe6, 0x90, 0x4c, 0xf7, 0x95, 0xf8, 0x30,
	0x6f, 0x20, 0xd9, 0x0e, 0xfb, 0x13, 0x5b, 0x24, 0x81, 0x35, 0xbb, 0xb3, 0xe9, 0xe8, 0xce, 0x3e,
	0x9b, 0x6d, 0x14, 0x9b, 0xd4, 0xad, 0xd8, 0x0a, 0xde, 0xd9, 0xa9, 0x26, 0x64, 0xe9, 0x05, 0x1d,
	0xbb, 0x8e, 0x90, 0xf5, 0x53, 0x4b, 0x41, 0xaa, 0x64, 0xf6, 0x4f, 0xa9, 0x3d, 0x39, 0x26, 0xf6,
	0x20, 0x24, 0x40, 0xa2, 0xaf, 0x66, 0xba, 0x9b, 0x9b, 0x9b, 0x8c, 0x69, 0xc1, 0xdb, 0xdb, 0x7b,
	0xf7, 0xf6, 0xbf, 0xbf, 0x2e, 0xfe, 0xc4, 0xc1, 0xea, 0x2d, 0xd7, 0xf5, 0x32, 0x5c, 0xd3, 0x1a,
	0xf5, 0x03, 0x16, 0x66, 0xfc, 0xef, 0x2f, 0x10, 0x82, 0xf4, 0x40, 0x77, 0x75, 0x21, 0x5d, 0x49,
	0x79, 0x33, 0xe3, 0x7d, 0xef, 0xfc, 0x93, 0x81, 0x5c, 0xf0, 0xda, 0xa3, 0x07, 0x80, 0x44, 0xa9,
	0xa3, 0xa9, 0xc7, 0x3d, 0xac, 0x1d, 0xca, 0x12, 0xde, 0x6f, 0xcb, 0x58, 0xe2, 0x13, 0xe8, 0x03,
	0x58, 0x9d, 0xfa, 0xd5, 0x23, 0x8d, 0xe0, 0xef, 0x0e, 0xb1, 0xa2, 0xf2, 0x1c, 0x12, 0x60, 0x2d,
	0x1a, 0x50, 0x7a, 0x5d, 0x59, 0xc1, 0x7c, 0x32, 0x42, 0xf5, 0x02, 0xab, 0x9a, 0xa2, 0xb6, 0x54,
	0xcc, 0xa7, 0xd0, 0x16, 0x7c, 0x18, 0xf7, 0x87, 0x89, 0x69, 0xb4, 0x01, 0xeb, 0x11, 0xc0, 0xf3,
	0x63, 0x15, 0x8b, 0x5d, 0x09, 0xf3, 0x19, 0x54, 0x85, 0xf2, 0xad, 0xa1, 0x30, 0x3d, 0x1b, 0xe1,
	0x17, 0x09, 0xf6, 0xc8, 0x5f, 0xbe, 0xd2, 0xda, 0x2a, 0x26, 0x2d, 0xb5, 0x4b, 0xf8, 0x1c, 0xaa,
	0xc1, 0xa3, 0x7b, 0x00, 0x21, 0x55, 0x1e, 0x55, 0x60, 0x33, 0x44, 0x76, 0x65, 0xe5, 0xb0, 0x13,
	0xe5, 0x2a, 0xa0, 0xc7, 0xb0, 0x7d, 0x1f, 0x22, 0x24, 0x03, 0xf4, 0x08, 0x2a, 0xb1, 0xb2, 0xf8,
	0x58, 0x3b, 0x68, 0x2b, 0x6a, 0x97, 0x1c, 0xfb, 0x29, 0xfc, 0x02, 0xfa, 0x0c, 0x6a, 0xf7, 0xa1,
	0x54, 0x3c, 0xc3, 0x59, 0x44, 0xdb, 0xf0, 0x71, 0xbc, 0xfc, 0x3c, 0xe9, 0x22, 0xaa, 0xc3, 0xce,
	0x7f, 0xc2, 0x42, 0xda, 0xa5, 0x78, 0x8b, 0xb0, 0x2c, 0x61, 0xa2, 0xb5, 0x24, 0x89, 0x60, 0x45,
	0xe1, 0x97, 0x23, 0x12, 0xc6, 0x01, 0x21, 0x15, 0x8f, 0xca, 0x50, 0x8a, 0x20, 0xc5, 0xae, 0xac,
	0x92, 0x96, 0xa8, 0x6a, 0x72, 0xab, 0x83, 0xf9, 0x15, 0xf4, 0x29, 0x3c, 0xbc, 0x3b, 0x1e, 0x12,
	0x21, 0xb4, 0x09, 0x42, 0xb4, 0xf5, 0x2d, 0x55, 0x3c, 0x08, 0x86, 0x6a, 0x35, 0x22, 0xc4, 0x5c,
	0x34, 0x24, 0x59, 0xdb, 0xf9, 0x04, 0x50, 0xfc, 0x2d, 0x44, 0x59, 0x48, 0x76, 0x5f, 0xf2, 0x09,
	0x94, 0x87, 0xf4, 0x7e, 0xab, 0xfd, 0x2d, 0xcf, 0xed, 0xfc, 0xca, 0x41, 0x31, 0x78, 0xf3, 0x15,
	0x57, 0x77, 0xbd, 0xff, 0x11, 0xeb, 0x3d, 0xd2, 0x15, 0xbd, 0xcb, 0x31, 0x52, 0xd6, 0x1b, 0x6f,
	0x35, 0x62, 0x21, 0x72, 0x28, 0xcb, 0x6d, 0xf9, 0x05, 0x5b, 0x8e, 0x68, 0x08, 0x1f, 0xf5, 0xda,
	0xc4, 0x5b, 0x8e, 0x4d, 0x10, 0xa2, 0x11, 0xf5, 0x48, 0x53, 0xdb, 0x1d, 0xdc, 0x3d, 0x54, 0xf9,
	0x94, 0x37, 0x77, 0xf3, 0xd5, 0xba, 0x8a, 0xa2, 0xed, 0xb7, 0xe5, 0xb6, 0x72, 0x80, 0x25, 0x3e,
	0x1d, 0xcf, 0x0f, 0x10, 0xde, 0xf1, 0x33, 0xcd, 0x7d, 0xc8, 0x8a, 0x52, 0x87, 0x58, 0x7d, 0xf4,
	0x0c, 0x96, 0x44, 0xa9, 0x23, 0x9a, 0x86, 0x71, 0x3e, 0x1e, 0xf5, 0xbd, 0x9b, 0xac, 0x84, 0xff,
	0xef, 0x82, 0x7f, 0x85, 0xa5, 0xb8, 0xab, 0x9a, 0xa8, 0x71, 0x9f, 0x73, 0xcf, 0xc9, 0xef, 0xd7,
	0x65, 0xee, 0xed, 0x75, 0x99, 0xfb, 0xfb, 0xba, 0xcc, 0xfd, 0x7c, 0x53, 0x4e, 0xbc, 0xbd, 0x29,
	0x27, 0xfe, 0xba, 0x29, 0x27, 0x7e, 0xd8, 0xf3, 0xdf, 0x51, 0x43, 0x3f, 0xa5, 0x76, 0xdd, 0xb4,
	0x87, 0x8d, 0xd0, 0x6c, 0x5c, 0x18, 0xbb, 0x03, 0xff, 0x7d, 0xdb, 0x1d, 0x9a, 0x8d, 0x0b, 0x43,
	0x33, 0x86, 0x76, 0xc3, 0x7a, 0xdd, 0xf0, 0x4b, 0x0c, 0xcd, 0xd7, 0x59, 0xff, 0xe3, 0xcb, 0x7f,
	0x03, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x00, 0x21, 0x98, 0xb4, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// CDMRpcClient is the client API for CDMRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type CDMRpcClient interface {
	CDMCommunicate(ctx context.Context, opts ...grpc.CallOption) (CDMRpc_CDMCommunicateClient, error)
}

type cDMRpcClient struct {
	cc *grpc.ClientConn
}

func NewCDMRpcClient(cc *grpc.ClientConn) CDMRpcClient {
	return &cDMRpcClient{cc}
}

func (c *cDMRpcClient) CDMCommunicate(ctx context.Context, opts ...grpc.CallOption) (CDMRpc_CDMCommunicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_CDMRpc_serviceDesc.Streams[0], "/proto.CDMRpc/CDMCommunicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &cDMRpcCDMCommunicateClient{stream}
	return x, nil
}

type CDMRpc_CDMCommunicateClient interface {
	Send(*CDMMessage) error
	Recv() (*CDMMessage, error)
	grpc.ClientStream
}

type cDMRpcCDMCommunicateClient struct {
	grpc.ClientStream
}

func (x *cDMRpcCDMCommunicateClient) Send(m *CDMMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *cDMRpcCDMCommunicateClient) Recv() (*CDMMessage, error) {
	m := new(CDMMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// CDMRpcServer is the server API for CDMRpc service.
type CDMRpcServer interface {
	CDMCommunicate(CDMRpc_CDMCommunicateServer) error
}

// UnimplementedCDMRpcServer can be embedded to have forward compatible implementations.
type UnimplementedCDMRpcServer struct {
}

func (*UnimplementedCDMRpcServer) CDMCommunicate(srv CDMRpc_CDMCommunicateServer) error {
	return status.Errorf(codes.Unimplemented, "method CDMCommunicate not implemented")
}

func RegisterCDMRpcServer(s *grpc.Server, srv CDMRpcServer) {
	s.RegisterService(&_CDMRpc_serviceDesc, srv)
}

func _CDMRpc_CDMCommunicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(CDMRpcServer).CDMCommunicate(&cDMRpcCDMCommunicateServer{stream})
}

type CDMRpc_CDMCommunicateServer interface {
	Send(*CDMMessage) error
	Recv() (*CDMMessage, error)
	grpc.ServerStream
}

type cDMRpcCDMCommunicateServer struct {
	grpc.ServerStream
}

func (x *cDMRpcCDMCommunicateServer) Send(m *CDMMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *cDMRpcCDMCommunicateServer) Recv() (*CDMMessage, error) {
	m := new(CDMMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _CDMRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.CDMRpc",
	HandlerType: (*CDMRpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CDMCommunicate",
			Handler:       _CDMRpc_CDMCommunicate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "cdm_message.proto",
}

func (m *CDMMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CDMMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CDMMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x42
	}
	if m.TxResponse != nil {
		{
			size, err := m.TxResponse.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCdmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.TxRequest != nil {
		{
			size, err := m.TxRequest.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCdmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if m.ResultCode != 0 {
		i = encodeVarintCdmMessage(dAtA, i, uint64(m.ResultCode))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintCdmMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.TxContext != nil {
		{
			size, err := m.TxContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCdmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCdmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCdmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.OriginalProcessName) > 0 {
		i -= len(m.OriginalProcessName)
		copy(dAtA[i:], m.OriginalProcessName)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.OriginalProcessName)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ReadMap) > 0 {
		for k := range m.ReadMap {
			v := m.ReadMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCdmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCdmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WriteMap) > 0 {
		for k := range m.WriteMap {
			v := m.WriteMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCdmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCdmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.CurrentHeight != 0 {
		i = encodeVarintCdmMessage(dAtA, i, uint64(m.CurrentHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ReadMap) > 0 {
		for k := range m.ReadMap {
			v := m.ReadMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCdmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCdmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCdmMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.WriteMap) > 0 {
		for k := range m.WriteMap {
			v := m.WriteMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintCdmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintCdmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintCdmMessage(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DockerContractEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerContractEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DockerContractEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Data[iNdEx])
			copy(dAtA[i:], m.Data[iNdEx])
			i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Data[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintCdmMessage(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintCdmMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovCdmMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CDMMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCdmMessage(uint64(m.Type))
	}
	if m.ResultCode != 0 {
		n += 1 + sovCdmMessage(uint64(m.ResultCode))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if m.TxRequest != nil {
		l = m.TxRequest.Size()
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if m.TxResponse != nil {
		l = m.TxResponse.Size()
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	return n
}

func (m *TxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCdmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCdmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCdmMessage(uint64(mapEntrySize))
		}
	}
	if m.TxContext != nil {
		l = m.TxContext.Size()
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	return n
}

func (m *TxContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentHeight != 0 {
		n += 1 + sovCdmMessage(uint64(m.CurrentHeight))
	}
	if len(m.WriteMap) > 0 {
		for k, v := range m.WriteMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCdmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCdmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCdmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ReadMap) > 0 {
		for k, v := range m.ReadMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCdmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCdmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCdmMessage(uint64(mapEntrySize))
		}
	}
	l = len(m.OriginalProcessName)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	return n
}

func (m *TxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovCdmMessage(uint64(m.Code))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if len(m.WriteMap) > 0 {
		for k, v := range m.WriteMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCdmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCdmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCdmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovCdmMessage(uint64(l))
		}
	}
	if len(m.ReadMap) > 0 {
		for k, v := range m.ReadMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovCdmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovCdmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovCdmMessage(uint64(mapEntrySize))
		}
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	return n
}

func (m *DockerContractEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovCdmMessage(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, s := range m.Data {
			l = len(s)
			n += 1 + l + sovCdmMessage(uint64(l))
		}
	}
	return n
}

func sovCdmMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCdmMessage(x uint64) (n int) {
	return sovCdmMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *CDMMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CDMMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CDMMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= CDMType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResultCode", wireType)
			}
			m.ResultCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ResultCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxRequest", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxRequest == nil {
				m.TxRequest = &TxRequest{}
			}
			if err := m.TxRequest.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxResponse", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxResponse == nil {
				m.TxResponse = &TxResponse{}
			}
			if err := m.TxResponse.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCdmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCdmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCdmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxContext == nil {
				m.TxContext = &TxContext{}
			}
			if err := m.TxContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCdmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentHeight", wireType)
			}
			m.CurrentHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentHeight |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteMap == nil {
				m.WriteMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCdmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCdmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WriteMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadMap == nil {
				m.ReadMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCdmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCdmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OriginalProcessName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OriginalProcessName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCdmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= ContractResultCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteMap == nil {
				m.WriteMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCdmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCdmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WriteMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &DockerContractEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadMap == nil {
				m.ReadMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCdmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCdmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthCdmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipCdmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthCdmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCdmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerContractEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerContractEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerContractEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCdmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCdmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthCdmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCdmMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCdmMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCdmMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCdmMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCdmMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCdmMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCdmMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCdmMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCdmMessage = fmt.Errorf("proto: unexpected end of group")
)
