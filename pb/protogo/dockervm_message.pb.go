// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: dockervm_message.proto

package protogo

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type DockerVMType int32

const (
	DockerVMType_UNDEFINED                         DockerVMType = 0
	DockerVMType_REGISTER                          DockerVMType = 1
	DockerVMType_REGISTERED                        DockerVMType = 2
	DockerVMType_PREPARE                           DockerVMType = 3
	DockerVMType_READY                             DockerVMType = 4
	DockerVMType_INIT                              DockerVMType = 5
	DockerVMType_INVOKE                            DockerVMType = 6
	DockerVMType_TX_REQUEST                        DockerVMType = 7
	DockerVMType_TX_RESPONSE                       DockerVMType = 8
	DockerVMType_GET_STATE_REQUEST                 DockerVMType = 9
	DockerVMType_GET_STATE_RESPONSE                DockerVMType = 10
	DockerVMType_GET_BYTECODE_REQUEST              DockerVMType = 11
	DockerVMType_GET_BYTECODE_RESPONSE             DockerVMType = 12
	DockerVMType_CALL_CONTRACT_REQUEST             DockerVMType = 13
	DockerVMType_CALL_CONTRACT_RESPONSE            DockerVMType = 14
	DockerVMType_COMPLETED                         DockerVMType = 15
	DockerVMType_ERROR                             DockerVMType = 16
	DockerVMType_CREATE_KV_ITERATOR_REQUEST        DockerVMType = 17
	DockerVMType_CREATE_KV_ITERATOR_RESPONSE       DockerVMType = 18
	DockerVMType_CONSUME_KV_ITERATOR_REQUEST       DockerVMType = 19
	DockerVMType_CONSUME_KV_ITERATOR_RESPONSE      DockerVMType = 20
	DockerVMType_CREATE_KEY_HISTORY_ITER_REQUEST   DockerVMType = 21
	DockerVMType_CREATE_KEY_HISTORY_TER_RESPONSE   DockerVMType = 22
	DockerVMType_CONSUME_KEY_HISTORY_ITER_REQUEST  DockerVMType = 23
	DockerVMType_CONSUME_KEY_HISTORY_ITER_RESPONSE DockerVMType = 24
	DockerVMType_GET_SENDER_ADDRESS_REQUEST        DockerVMType = 25
	DockerVMType_GET_SENDER_ADDRESS_RESPONSE       DockerVMType = 26
	DockerVMType_GET_BATCH_STATE_REQUEST           DockerVMType = 27
	DockerVMType_GET_BATCH_STATE_RESPONSE          DockerVMType = 28
)

var DockerVMType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "REGISTER",
	2:  "REGISTERED",
	3:  "PREPARE",
	4:  "READY",
	5:  "INIT",
	6:  "INVOKE",
	7:  "TX_REQUEST",
	8:  "TX_RESPONSE",
	9:  "GET_STATE_REQUEST",
	10: "GET_STATE_RESPONSE",
	11: "GET_BYTECODE_REQUEST",
	12: "GET_BYTECODE_RESPONSE",
	13: "CALL_CONTRACT_REQUEST",
	14: "CALL_CONTRACT_RESPONSE",
	15: "COMPLETED",
	16: "ERROR",
	17: "CREATE_KV_ITERATOR_REQUEST",
	18: "CREATE_KV_ITERATOR_RESPONSE",
	19: "CONSUME_KV_ITERATOR_REQUEST",
	20: "CONSUME_KV_ITERATOR_RESPONSE",
	21: "CREATE_KEY_HISTORY_ITER_REQUEST",
	22: "CREATE_KEY_HISTORY_TER_RESPONSE",
	23: "CONSUME_KEY_HISTORY_ITER_REQUEST",
	24: "CONSUME_KEY_HISTORY_ITER_RESPONSE",
	25: "GET_SENDER_ADDRESS_REQUEST",
	26: "GET_SENDER_ADDRESS_RESPONSE",
	27: "GET_BATCH_STATE_REQUEST",
	28: "GET_BATCH_STATE_RESPONSE",
}

var DockerVMType_value = map[string]int32{
	"UNDEFINED":                         0,
	"REGISTER":                          1,
	"REGISTERED":                        2,
	"PREPARE":                           3,
	"READY":                             4,
	"INIT":                              5,
	"INVOKE":                            6,
	"TX_REQUEST":                        7,
	"TX_RESPONSE":                       8,
	"GET_STATE_REQUEST":                 9,
	"GET_STATE_RESPONSE":                10,
	"GET_BYTECODE_REQUEST":              11,
	"GET_BYTECODE_RESPONSE":             12,
	"CALL_CONTRACT_REQUEST":             13,
	"CALL_CONTRACT_RESPONSE":            14,
	"COMPLETED":                         15,
	"ERROR":                             16,
	"CREATE_KV_ITERATOR_REQUEST":        17,
	"CREATE_KV_ITERATOR_RESPONSE":       18,
	"CONSUME_KV_ITERATOR_REQUEST":       19,
	"CONSUME_KV_ITERATOR_RESPONSE":      20,
	"CREATE_KEY_HISTORY_ITER_REQUEST":   21,
	"CREATE_KEY_HISTORY_TER_RESPONSE":   22,
	"CONSUME_KEY_HISTORY_ITER_REQUEST":  23,
	"CONSUME_KEY_HISTORY_ITER_RESPONSE": 24,
	"GET_SENDER_ADDRESS_REQUEST":        25,
	"GET_SENDER_ADDRESS_RESPONSE":       26,
	"GET_BATCH_STATE_REQUEST":           27,
	"GET_BATCH_STATE_RESPONSE":          28,
}

func (x DockerVMType) String() string {
	return proto.EnumName(DockerVMType_name, int32(x))
}

func (DockerVMType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{0}
}

type DockerVMCode int32

const (
	DockerVMCode_OK   DockerVMCode = 0
	DockerVMCode_FAIL DockerVMCode = 1
)

var DockerVMCode_name = map[int32]string{
	0: "OK",
	1: "FAIL",
}

var DockerVMCode_value = map[string]int32{
	"OK":   0,
	"FAIL": 1,
}

func (x DockerVMCode) String() string {
	return proto.EnumName(DockerVMCode_name, int32(x))
}

func (DockerVMCode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{1}
}

//DockerVMMessage means message between chainmaker and docker vm
type DockerVMMessage struct {
	TxId         string        `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Type         DockerVMType  `protobuf:"varint,2,opt,name=type,proto3,enum=proto.DockerVMType" json:"type,omitempty"`
	CrossContext *CrossContext `protobuf:"bytes,3,opt,name=cross_context,json=crossContext,proto3" json:"cross_context,omitempty"`
	// if not used, set to nil
	SysCallMessage *SysCallMessage `protobuf:"bytes,4,opt,name=sys_call_message,json=sysCallMessage,proto3" json:"sys_call_message,omitempty"`
	// if not used, set to nil
	Request *TxRequest `protobuf:"bytes,5,opt,name=request,proto3" json:"request,omitempty"`
	// if not used, set to nil
	Response *TxResponse `protobuf:"bytes,6,opt,name=response,proto3" json:"response,omitempty"`
	ChainId  string      `protobuf:"bytes,7,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *DockerVMMessage) Reset()         { *m = DockerVMMessage{} }
func (m *DockerVMMessage) String() string { return proto.CompactTextString(m) }
func (*DockerVMMessage) ProtoMessage()    {}
func (*DockerVMMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{0}
}
func (m *DockerVMMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DockerVMMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DockerVMMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DockerVMMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DockerVMMessage.Merge(m, src)
}
func (m *DockerVMMessage) XXX_Size() int {
	return m.Size()
}
func (m *DockerVMMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_DockerVMMessage.DiscardUnknown(m)
}

var xxx_messageInfo_DockerVMMessage proto.InternalMessageInfo

func (m *DockerVMMessage) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *DockerVMMessage) GetType() DockerVMType {
	if m != nil {
		return m.Type
	}
	return DockerVMType_UNDEFINED
}

func (m *DockerVMMessage) GetCrossContext() *CrossContext {
	if m != nil {
		return m.CrossContext
	}
	return nil
}

func (m *DockerVMMessage) GetSysCallMessage() *SysCallMessage {
	if m != nil {
		return m.SysCallMessage
	}
	return nil
}

func (m *DockerVMMessage) GetRequest() *TxRequest {
	if m != nil {
		return m.Request
	}
	return nil
}

func (m *DockerVMMessage) GetResponse() *TxResponse {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *DockerVMMessage) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type SysCallMessage struct {
	Code    DockerVMCode `protobuf:"varint,1,opt,name=code,proto3,enum=proto.DockerVMCode" json:"code,omitempty"`
	Message string       `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// if not used, set to nil
	Payload map[string][]byte `protobuf:"bytes,3,rep,name=payload,proto3" json:"payload,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *SysCallMessage) Reset()         { *m = SysCallMessage{} }
func (m *SysCallMessage) String() string { return proto.CompactTextString(m) }
func (*SysCallMessage) ProtoMessage()    {}
func (*SysCallMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{1}
}
func (m *SysCallMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysCallMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysCallMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysCallMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysCallMessage.Merge(m, src)
}
func (m *SysCallMessage) XXX_Size() int {
	return m.Size()
}
func (m *SysCallMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_SysCallMessage.DiscardUnknown(m)
}

var xxx_messageInfo_SysCallMessage proto.InternalMessageInfo

func (m *SysCallMessage) GetCode() DockerVMCode {
	if m != nil {
		return m.Code
	}
	return DockerVMCode_OK
}

func (m *SysCallMessage) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *SysCallMessage) GetPayload() map[string][]byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

type CrossContext struct {
	CurrentDepth uint32 `protobuf:"varint,1,opt,name=current_depth,json=currentDepth,proto3" json:"current_depth,omitempty"`
	ProcessName  string `protobuf:"bytes,2,opt,name=process_name,json=processName,proto3" json:"process_name,omitempty"`
	//
	//63          59           43                   0
	//+----------+^-----------+-^---------+-^-------
	//|   4bits   |   16bits    |   .....   | 4bits|
	//+----------+^-----------+-^---------+-^-------
	//depth_count | history_flag | vec<runtime_type>
	//the length of vec is controlled by depth_count
	CrossInfo uint64 `protobuf:"varint,3,opt,name=cross_info,json=crossInfo,proto3" json:"cross_info,omitempty"`
}

func (m *CrossContext) Reset()         { *m = CrossContext{} }
func (m *CrossContext) String() string { return proto.CompactTextString(m) }
func (*CrossContext) ProtoMessage()    {}
func (*CrossContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{2}
}
func (m *CrossContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossContext.Merge(m, src)
}
func (m *CrossContext) XXX_Size() int {
	return m.Size()
}
func (m *CrossContext) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossContext.DiscardUnknown(m)
}

var xxx_messageInfo_CrossContext proto.InternalMessageInfo

func (m *CrossContext) GetCurrentDepth() uint32 {
	if m != nil {
		return m.CurrentDepth
	}
	return 0
}

func (m *CrossContext) GetProcessName() string {
	if m != nil {
		return m.ProcessName
	}
	return ""
}

func (m *CrossContext) GetCrossInfo() uint64 {
	if m != nil {
		return m.CrossInfo
	}
	return 0
}

// TX_REQUEST
type TxRequest struct {
	ContractName    string            `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractVersion string            `protobuf:"bytes,2,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	Method          string            `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	Parameters      map[string][]byte `protobuf:"bytes,4,rep,name=parameters,proto3" json:"parameters,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// cross contract in use
	TxContext *TxContext `protobuf:"bytes,5,opt,name=tx_context,json=txContext,proto3" json:"tx_context,omitempty"`
	ChainId   string     `protobuf:"bytes,6,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *TxRequest) Reset()         { *m = TxRequest{} }
func (m *TxRequest) String() string { return proto.CompactTextString(m) }
func (*TxRequest) ProtoMessage()    {}
func (*TxRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{3}
}
func (m *TxRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxRequest.Merge(m, src)
}
func (m *TxRequest) XXX_Size() int {
	return m.Size()
}
func (m *TxRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TxRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TxRequest proto.InternalMessageInfo

func (m *TxRequest) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *TxRequest) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *TxRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *TxRequest) GetParameters() map[string][]byte {
	if m != nil {
		return m.Parameters
	}
	return nil
}

func (m *TxRequest) GetTxContext() *TxContext {
	if m != nil {
		return m.TxContext
	}
	return nil
}

func (m *TxRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

type TxContext struct {
	WriteMap map[string][]byte `protobuf:"bytes,1,rep,name=write_map,json=writeMap,proto3" json:"write_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadMap  map[string][]byte `protobuf:"bytes,2,rep,name=read_map,json=readMap,proto3" json:"read_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *TxContext) Reset()         { *m = TxContext{} }
func (m *TxContext) String() string { return proto.CompactTextString(m) }
func (*TxContext) ProtoMessage()    {}
func (*TxContext) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{4}
}
func (m *TxContext) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxContext) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxContext.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxContext) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxContext.Merge(m, src)
}
func (m *TxContext) XXX_Size() int {
	return m.Size()
}
func (m *TxContext) XXX_DiscardUnknown() {
	xxx_messageInfo_TxContext.DiscardUnknown(m)
}

var xxx_messageInfo_TxContext proto.InternalMessageInfo

func (m *TxContext) GetWriteMap() map[string][]byte {
	if m != nil {
		return m.WriteMap
	}
	return nil
}

func (m *TxContext) GetReadMap() map[string][]byte {
	if m != nil {
		return m.ReadMap
	}
	return nil
}

// TX_RESPONSE
type TxResponse struct {
	TxId            string                 `protobuf:"bytes,1,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
	Code            DockerVMCode           `protobuf:"varint,2,opt,name=code,proto3,enum=proto.DockerVMCode" json:"code,omitempty"`
	Result          []byte                 `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
	Message         string                 `protobuf:"bytes,4,opt,name=message,proto3" json:"message,omitempty"`
	WriteMap        map[string][]byte      `protobuf:"bytes,5,rep,name=write_map,json=writeMap,proto3" json:"write_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	ReadMap         map[string][]byte      `protobuf:"bytes,6,rep,name=read_map,json=readMap,proto3" json:"read_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Events          []*DockerContractEvent `protobuf:"bytes,7,rep,name=events,proto3" json:"events,omitempty"`
	ContractName    string                 `protobuf:"bytes,8,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractVersion string                 `protobuf:"bytes,9,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	ChainId         string                 `protobuf:"bytes,10,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TxDuration      *TxDuration            `protobuf:"bytes,11,opt,name=tx_duration,json=txDuration,proto3" json:"tx_duration,omitempty"`
}

func (m *TxResponse) Reset()         { *m = TxResponse{} }
func (m *TxResponse) String() string { return proto.CompactTextString(m) }
func (*TxResponse) ProtoMessage()    {}
func (*TxResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{5}
}
func (m *TxResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxResponse.Merge(m, src)
}
func (m *TxResponse) XXX_Size() int {
	return m.Size()
}
func (m *TxResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TxResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TxResponse proto.InternalMessageInfo

func (m *TxResponse) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

func (m *TxResponse) GetCode() DockerVMCode {
	if m != nil {
		return m.Code
	}
	return DockerVMCode_OK
}

func (m *TxResponse) GetResult() []byte {
	if m != nil {
		return m.Result
	}
	return nil
}

func (m *TxResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *TxResponse) GetWriteMap() map[string][]byte {
	if m != nil {
		return m.WriteMap
	}
	return nil
}

func (m *TxResponse) GetReadMap() map[string][]byte {
	if m != nil {
		return m.ReadMap
	}
	return nil
}

func (m *TxResponse) GetEvents() []*DockerContractEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func (m *TxResponse) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *TxResponse) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *TxResponse) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *TxResponse) GetTxDuration() *TxDuration {
	if m != nil {
		return m.TxDuration
	}
	return nil
}

type DockerContractEvent struct {
	// Event topic
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// Event contract name
	ContractName string `protobuf:"bytes,2,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// Event payload
	Data []string `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *DockerContractEvent) Reset()         { *m = DockerContractEvent{} }
func (m *DockerContractEvent) String() string { return proto.CompactTextString(m) }
func (*DockerContractEvent) ProtoMessage()    {}
func (*DockerContractEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{6}
}
func (m *DockerContractEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DockerContractEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DockerContractEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DockerContractEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DockerContractEvent.Merge(m, src)
}
func (m *DockerContractEvent) XXX_Size() int {
	return m.Size()
}
func (m *DockerContractEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_DockerContractEvent.DiscardUnknown(m)
}

var xxx_messageInfo_DockerContractEvent proto.InternalMessageInfo

func (m *DockerContractEvent) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *DockerContractEvent) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *DockerContractEvent) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

// ============== DMS pb ==============
// --------------------  request message ---------------------
type CallContractRequest struct {
	ContractName   string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	ContractMethod string `protobuf:"bytes,2,opt,name=contract_method,json=contractMethod,proto3" json:"contract_method,omitempty"`
	// args
	Args map[string][]byte `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *CallContractRequest) Reset()         { *m = CallContractRequest{} }
func (m *CallContractRequest) String() string { return proto.CompactTextString(m) }
func (*CallContractRequest) ProtoMessage()    {}
func (*CallContractRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{7}
}
func (m *CallContractRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CallContractRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CallContractRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CallContractRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CallContractRequest.Merge(m, src)
}
func (m *CallContractRequest) XXX_Size() int {
	return m.Size()
}
func (m *CallContractRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_CallContractRequest.DiscardUnknown(m)
}

var xxx_messageInfo_CallContractRequest proto.InternalMessageInfo

func (m *CallContractRequest) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *CallContractRequest) GetContractMethod() string {
	if m != nil {
		return m.ContractMethod
	}
	return ""
}

func (m *CallContractRequest) GetArgs() map[string][]byte {
	if m != nil {
		return m.Args
	}
	return nil
}

// user method response
type Response struct {
	// A status code that should follow the HTTP status codes.
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// A message associated with the response code. error has message
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// A payload that can be used to include metadata with this response. success with payload
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{8}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func (m *Response) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *Response) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *Response) GetPayload() []byte {
	if m != nil {
		return m.Payload
	}
	return nil
}

// real user contract response
type ContractResponse struct {
	// always has response
	Response *Response `protobuf:"bytes,1,opt,name=response,proto3" json:"response,omitempty"`
	// always has write map
	WriteMap map[string][]byte `protobuf:"bytes,2,rep,name=write_map,json=writeMap,proto3" json:"write_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// only cross contracts has read map
	ReadMap map[string][]byte `protobuf:"bytes,3,rep,name=read_map,json=readMap,proto3" json:"read_map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// always has events
	Events []*Event `protobuf:"bytes,4,rep,name=events,proto3" json:"events,omitempty"`
}

func (m *ContractResponse) Reset()         { *m = ContractResponse{} }
func (m *ContractResponse) String() string { return proto.CompactTextString(m) }
func (*ContractResponse) ProtoMessage()    {}
func (*ContractResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{9}
}
func (m *ContractResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractResponse.Merge(m, src)
}
func (m *ContractResponse) XXX_Size() int {
	return m.Size()
}
func (m *ContractResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ContractResponse proto.InternalMessageInfo

func (m *ContractResponse) GetResponse() *Response {
	if m != nil {
		return m.Response
	}
	return nil
}

func (m *ContractResponse) GetWriteMap() map[string][]byte {
	if m != nil {
		return m.WriteMap
	}
	return nil
}

func (m *ContractResponse) GetReadMap() map[string][]byte {
	if m != nil {
		return m.ReadMap
	}
	return nil
}

func (m *ContractResponse) GetEvents() []*Event {
	if m != nil {
		return m.Events
	}
	return nil
}

type Event struct {
	// Event topic
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// Event contract name
	ContractName string `protobuf:"bytes,2,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// Event payload
	Data []string `protobuf:"bytes,3,rep,name=data,proto3" json:"data,omitempty"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{10}
}
func (m *Event) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Event.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return m.Size()
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Event) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *Event) GetData() []string {
	if m != nil {
		return m.Data
	}
	return nil
}

type TxDuration struct {
	CrossCallCnt  int32 `protobuf:"varint,1,opt,name=CrossCallCnt,proto3" json:"CrossCallCnt,omitempty"`
	CrossCallTime int64 `protobuf:"varint,2,opt,name=CrossCallTime,proto3" json:"CrossCallTime,omitempty"`
}

func (m *TxDuration) Reset()         { *m = TxDuration{} }
func (m *TxDuration) String() string { return proto.CompactTextString(m) }
func (*TxDuration) ProtoMessage()    {}
func (*TxDuration) Descriptor() ([]byte, []int) {
	return fileDescriptor_23619f598d968e93, []int{11}
}
func (m *TxDuration) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxDuration) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxDuration.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxDuration) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxDuration.Merge(m, src)
}
func (m *TxDuration) XXX_Size() int {
	return m.Size()
}
func (m *TxDuration) XXX_DiscardUnknown() {
	xxx_messageInfo_TxDuration.DiscardUnknown(m)
}

var xxx_messageInfo_TxDuration proto.InternalMessageInfo

func (m *TxDuration) GetCrossCallCnt() int32 {
	if m != nil {
		return m.CrossCallCnt
	}
	return 0
}

func (m *TxDuration) GetCrossCallTime() int64 {
	if m != nil {
		return m.CrossCallTime
	}
	return 0
}

func init() {
	proto.RegisterEnum("proto.DockerVMType", DockerVMType_name, DockerVMType_value)
	proto.RegisterEnum("proto.DockerVMCode", DockerVMCode_name, DockerVMCode_value)
	proto.RegisterType((*DockerVMMessage)(nil), "proto.DockerVMMessage")
	proto.RegisterType((*SysCallMessage)(nil), "proto.SysCallMessage")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.SysCallMessage.PayloadEntry")
	proto.RegisterType((*CrossContext)(nil), "proto.CrossContext")
	proto.RegisterType((*TxRequest)(nil), "proto.TxRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxRequest.ParametersEntry")
	proto.RegisterType((*TxContext)(nil), "proto.TxContext")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxContext.ReadMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxContext.WriteMapEntry")
	proto.RegisterType((*TxResponse)(nil), "proto.TxResponse")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxResponse.ReadMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.TxResponse.WriteMapEntry")
	proto.RegisterType((*DockerContractEvent)(nil), "proto.DockerContractEvent")
	proto.RegisterType((*CallContractRequest)(nil), "proto.CallContractRequest")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.CallContractRequest.ArgsEntry")
	proto.RegisterType((*Response)(nil), "proto.Response")
	proto.RegisterType((*ContractResponse)(nil), "proto.ContractResponse")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.ContractResponse.ReadMapEntry")
	proto.RegisterMapType((map[string][]byte)(nil), "proto.ContractResponse.WriteMapEntry")
	proto.RegisterType((*Event)(nil), "proto.Event")
	proto.RegisterType((*TxDuration)(nil), "proto.TxDuration")
}

func init() { proto.RegisterFile("dockervm_message.proto", fileDescriptor_23619f598d968e93) }

var fileDescriptor_23619f598d968e93 = []byte{
	// 1366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x4f, 0x73, 0xd3, 0x46,
	0x14, 0x8f, 0x1c, 0xff, 0x7d, 0x76, 0x12, 0xb1, 0x21, 0x46, 0x18, 0x30, 0xc6, 0x84, 0x21, 0xa5,
	0x83, 0xd3, 0x49, 0xa7, 0xd3, 0x14, 0xda, 0xa1, 0xc6, 0x16, 0xe0, 0x49, 0x62, 0xa7, 0x6b, 0xe1,
	0x36, 0x5c, 0x34, 0xc2, 0x5a, 0x8c, 0x07, 0x5b, 0x52, 0xa5, 0x75, 0x88, 0xbf, 0x45, 0x3f, 0x52,
	0x7b, 0xeb, 0xa5, 0x33, 0x9c, 0x98, 0x1e, 0x3b, 0xe4, 0x63, 0xf4, 0xd2, 0xd9, 0xd5, 0x4a, 0x91,
	0x65, 0x87, 0x36, 0x87, 0x0e, 0xa7, 0xe8, 0xbd, 0xfd, 0xfd, 0xde, 0xdb, 0xfd, 0xed, 0x7b, 0x6f,
	0x1d, 0x28, 0x9a, 0x76, 0xff, 0x0d, 0x71, 0x8f, 0xc7, 0xfa, 0x98, 0x78, 0x9e, 0x31, 0x20, 0x35,
	0xc7, 0xb5, 0xa9, 0x8d, 0x52, 0xfc, 0x4f, 0xf5, 0xd7, 0x04, 0xac, 0x35, 0x39, 0xa2, 0x77, 0x70,
	0xe0, 0x03, 0xd0, 0x3a, 0xa4, 0xe8, 0x89, 0x3e, 0x34, 0x15, 0xa9, 0x22, 0x6d, 0xe5, 0x70, 0x92,
	0x9e, 0xb4, 0x4c, 0x74, 0x17, 0x92, 0x74, 0xea, 0x10, 0x25, 0x51, 0x91, 0xb6, 0x56, 0x77, 0xd6,
	0xfd, 0x28, 0xb5, 0x80, 0xaa, 0x4d, 0x1d, 0x82, 0x39, 0x00, 0xed, 0xc2, 0x4a, 0xdf, 0xb5, 0x3d,
	0x4f, 0xef, 0xdb, 0x16, 0x25, 0x27, 0x54, 0x59, 0xae, 0x48, 0x5b, 0xf9, 0x90, 0xd1, 0x60, 0x6b,
	0x0d, 0x7f, 0x09, 0x17, 0xfa, 0x11, 0x0b, 0x3d, 0x02, 0xd9, 0x9b, 0x7a, 0x7a, 0xdf, 0x18, 0x8d,
	0x82, 0xcd, 0x2a, 0x49, 0x4e, 0xde, 0x10, 0xe4, 0xee, 0xd4, 0x6b, 0x18, 0xa3, 0x91, 0xd8, 0x28,
	0x5e, 0xf5, 0x66, 0x6c, 0x74, 0x0f, 0x32, 0x2e, 0xf9, 0x79, 0x42, 0x3c, 0xaa, 0xa4, 0x38, 0x4f,
	0x16, 0x3c, 0xed, 0x04, 0xfb, 0x7e, 0x1c, 0x00, 0xd0, 0x7d, 0xc8, 0xba, 0xc4, 0x73, 0x6c, 0xcb,
	0x23, 0x4a, 0x9a, 0x83, 0x2f, 0x45, 0xc0, 0xfe, 0x02, 0x0e, 0x21, 0xe8, 0x2a, 0x64, 0xfb, 0xaf,
	0x8d, 0xa1, 0xc5, 0x64, 0xc9, 0x70, 0x59, 0x32, 0xdc, 0x6e, 0x99, 0xd5, 0x3f, 0x24, 0x58, 0x9d,
	0xdd, 0x18, 0x13, 0xab, 0x6f, 0x9b, 0x84, 0x0b, 0x38, 0x2f, 0x56, 0xc3, 0x36, 0x09, 0xe6, 0x00,
	0xa4, 0x40, 0x26, 0x38, 0x69, 0xc2, 0x8f, 0x2a, 0x4c, 0xf4, 0x2d, 0x64, 0x1c, 0x63, 0x3a, 0xb2,
	0x0d, 0x53, 0x59, 0xae, 0x2c, 0x6f, 0xe5, 0x77, 0xaa, 0x0b, 0x35, 0xa8, 0x1d, 0xfa, 0x20, 0xd5,
	0xa2, 0xee, 0x14, 0x07, 0x94, 0xd2, 0x03, 0x28, 0x44, 0x17, 0x90, 0x0c, 0xcb, 0x6f, 0xc8, 0x54,
	0x5c, 0x28, 0xfb, 0x44, 0x97, 0x21, 0x75, 0x6c, 0x8c, 0x26, 0x7e, 0xde, 0x02, 0xf6, 0x8d, 0x07,
	0x89, 0x5d, 0xa9, 0x3a, 0x81, 0x42, 0xf4, 0x92, 0xd0, 0x6d, 0x58, 0xe9, 0x4f, 0x5c, 0x97, 0x58,
	0x54, 0x37, 0x89, 0x43, 0x5f, 0xf3, 0x28, 0x2b, 0xb8, 0x20, 0x9c, 0x4d, 0xe6, 0x43, 0xb7, 0xa0,
	0xe0, 0xb8, 0x76, 0x9f, 0x78, 0x9e, 0x6e, 0x19, 0xe3, 0xe0, 0x34, 0x79, 0xe1, 0x6b, 0x1b, 0x63,
	0x82, 0x6e, 0x00, 0xf8, 0x85, 0x31, 0xb4, 0x5e, 0xd9, 0xbc, 0x2a, 0x92, 0x38, 0xc7, 0x3d, 0x2d,
	0xeb, 0x15, 0xaf, 0xc4, 0x5c, 0x78, 0x4f, 0x3c, 0xa9, 0x6d, 0x51, 0xd7, 0xe8, 0x53, 0x3f, 0xa0,
	0xbf, 0xf5, 0x42, 0xe0, 0xe4, 0x11, 0x3f, 0x03, 0x39, 0x04, 0x1d, 0x13, 0xd7, 0x1b, 0xda, 0x96,
	0x48, 0xbc, 0x16, 0xf8, 0x7b, 0xbe, 0x1b, 0x15, 0x21, 0x3d, 0x26, 0xf4, 0xb5, 0x6d, 0xf2, 0xc4,
	0x39, 0x2c, 0x2c, 0xf4, 0x3d, 0x80, 0x63, 0xb8, 0xc6, 0x98, 0x50, 0xe2, 0x7a, 0x4a, 0x92, 0x2b,
	0x5d, 0x89, 0x57, 0x4d, 0xed, 0x30, 0x84, 0xf8, 0x3a, 0x47, 0x38, 0x68, 0x1b, 0x80, 0x9e, 0x84,
	0xc5, 0x1e, 0xaf, 0xbb, 0xa0, 0xd2, 0x73, 0x34, 0xf8, 0x9c, 0x29, 0xa5, 0xf4, 0x4c, 0x29, 0x95,
	0xbe, 0x83, 0xb5, 0x58, 0xaa, 0x0b, 0xdd, 0xdc, 0xdf, 0x12, 0x93, 0x30, 0xc8, 0xf3, 0x10, 0x72,
	0x6f, 0xdd, 0x21, 0x25, 0xfa, 0xd8, 0x70, 0x14, 0x89, 0x9f, 0xac, 0x1c, 0xdf, 0x57, 0xed, 0x47,
	0x86, 0x38, 0x30, 0x1c, 0xff, 0x5c, 0xd9, 0xb7, 0xc2, 0x44, 0xbb, 0xac, 0x3d, 0x0c, 0x93, 0x73,
	0x13, 0x9c, 0x7b, 0x63, 0x8e, 0x8b, 0x89, 0x61, 0x86, 0xd4, 0x8c, 0xeb, 0x5b, 0xa5, 0x87, 0xb0,
	0x32, 0x13, 0xf4, 0x22, 0x27, 0x60, 0x75, 0x1b, 0x8d, 0x7a, 0xa1, 0xd3, 0xff, 0x96, 0x04, 0x38,
	0xeb, 0xdd, 0x73, 0xa7, 0x18, 0x6f, 0xcc, 0xc4, 0xbf, 0x35, 0x66, 0x11, 0xd2, 0x2e, 0xf1, 0x26,
	0x23, 0x7f, 0x7c, 0x15, 0xb0, 0xb0, 0xa2, 0x0d, 0x9b, 0x8c, 0x37, 0x6c, 0x44, 0xee, 0x14, 0x97,
	0xec, 0xe6, 0xdc, 0x44, 0x39, 0x57, 0xef, 0x6f, 0x22, 0x7a, 0xa7, 0x63, 0x77, 0x15, 0x92, 0x17,
	0x0a, 0x8e, 0x76, 0x20, 0x4d, 0x8e, 0x89, 0x45, 0x3d, 0x25, 0xc3, 0x89, 0xa5, 0x99, 0x53, 0x35,
	0x44, 0x23, 0xa8, 0x0c, 0x82, 0x05, 0x72, 0xbe, 0xbd, 0xb2, 0xff, 0xb1, 0xbd, 0x72, 0x8b, 0xdb,
	0x2b, 0x5a, 0xd3, 0x30, 0x53, 0xd3, 0x68, 0x07, 0xf2, 0xf4, 0x44, 0x37, 0x27, 0xae, 0x41, 0x59,
	0x80, 0x7c, 0x6c, 0xd6, 0x36, 0xc5, 0x02, 0x06, 0x1a, 0x7e, 0x7f, 0xba, 0x1a, 0x32, 0x61, 0x7d,
	0x81, 0x6c, 0x8c, 0x40, 0x6d, 0x67, 0xd8, 0x17, 0x41, 0x7c, 0x63, 0x5e, 0xc4, 0xc4, 0x02, 0x11,
	0x11, 0x24, 0x4d, 0x83, 0x1a, 0x7c, 0x88, 0xe7, 0x30, 0xff, 0xae, 0xbe, 0x97, 0x60, 0x9d, 0xcd,
	0xf0, 0x20, 0xc9, 0x85, 0x86, 0xde, 0x5d, 0x08, 0xd5, 0xd7, 0xc5, 0x48, 0xf3, 0xf3, 0xae, 0x06,
	0xee, 0x03, 0x7f, 0xb4, 0xed, 0x42, 0xd2, 0x70, 0x07, 0x9e, 0x78, 0x3e, 0x36, 0x83, 0xf7, 0x77,
	0x3e, 0x6f, 0xad, 0xee, 0x0e, 0xc4, 0x60, 0xe3, 0x8c, 0xd2, 0xd7, 0x90, 0x0b, 0x5d, 0x17, 0x92,
	0xaf, 0x07, 0xd9, 0xb0, 0xff, 0x8a, 0x90, 0xf6, 0xa8, 0x41, 0x27, 0x1e, 0xa7, 0xa6, 0xb0, 0xb0,
	0x3e, 0xf2, 0xe4, 0x29, 0xd1, 0x27, 0x8f, 0x45, 0x0e, 0xcc, 0xea, 0x69, 0x02, 0xe4, 0xb3, 0x4d,
	0x8b, 0x04, 0x9f, 0x47, 0x5e, 0x70, 0x89, 0x57, 0xd5, 0x9a, 0x38, 0xe3, 0x82, 0xf7, 0xfb, 0x71,
	0xb4, 0x3b, 0xfd, 0x81, 0x76, 0x27, 0x50, 0x24, 0x16, 0xf8, 0xdc, 0x1e, 0x7d, 0x14, 0xe9, 0xd1,
	0x98, 0xa8, 0xf1, 0x10, 0x8b, 0x3b, 0x75, 0x33, 0xec, 0x54, 0xff, 0xa1, 0x29, 0x08, 0xfa, 0x4c,
	0x6f, 0x7e, 0xba, 0xe2, 0xef, 0x41, 0xea, 0x7f, 0x29, 0xf7, 0x1e, 0x9b, 0xcb, 0x41, 0x6f, 0xa3,
	0x6a, 0xf0, 0xf3, 0x82, 0x15, 0xa2, 0x45, 0x45, 0x75, 0xcc, 0xf8, 0xd0, 0x26, 0xac, 0x84, 0xb6,
	0x36, 0x14, 0xa9, 0x96, 0xf1, 0xac, 0xf3, 0xde, 0xfb, 0x14, 0x14, 0xa2, 0x3f, 0x40, 0xd1, 0x0a,
	0xe4, 0x9e, 0xb7, 0x9b, 0xea, 0x93, 0x56, 0x5b, 0x6d, 0xca, 0x4b, 0xa8, 0x00, 0x59, 0xac, 0x3e,
	0x6d, 0x75, 0x35, 0x15, 0xcb, 0x12, 0x5a, 0x05, 0x08, 0x2c, 0xb5, 0x29, 0x27, 0x50, 0x1e, 0x32,
	0x87, 0x58, 0x3d, 0xac, 0x63, 0x55, 0x5e, 0x46, 0x39, 0x48, 0x61, 0xb5, 0xde, 0x3c, 0x92, 0x93,
	0x28, 0x0b, 0xc9, 0x56, 0xbb, 0xa5, 0xc9, 0x29, 0x04, 0x90, 0x6e, 0xb5, 0x7b, 0x9d, 0x3d, 0x55,
	0x4e, 0x33, 0xb6, 0xf6, 0x93, 0x8e, 0xd5, 0x1f, 0x9e, 0xab, 0x5d, 0x4d, 0xce, 0xa0, 0x35, 0xc8,
	0x73, 0xbb, 0x7b, 0xd8, 0x69, 0x77, 0x55, 0x39, 0x8b, 0x36, 0xe0, 0xd2, 0x53, 0x55, 0xd3, 0xbb,
	0x5a, 0x5d, 0x53, 0x43, 0x5c, 0x0e, 0x15, 0x01, 0x45, 0xdd, 0x02, 0x0e, 0x48, 0x81, 0xcb, 0xcc,
	0xff, 0xf8, 0x48, 0x53, 0x1b, 0x9d, 0xe6, 0x19, 0x23, 0x8f, 0xae, 0xc2, 0x46, 0x6c, 0x45, 0x90,
	0x0a, 0x6c, 0xa9, 0x51, 0xdf, 0xdf, 0xd7, 0x1b, 0x9d, 0xb6, 0x86, 0xeb, 0x0d, 0x2d, 0x64, 0xad,
	0xa0, 0x12, 0x14, 0xe3, 0x4b, 0x82, 0xb6, 0xca, 0x64, 0x69, 0x74, 0x0e, 0x0e, 0xf7, 0x55, 0x4d,
	0x6d, 0xca, 0x6b, 0xec, 0xac, 0x2a, 0xc6, 0x1d, 0x2c, 0xcb, 0xa8, 0x0c, 0xa5, 0x06, 0x56, 0xd9,
	0xd6, 0xf6, 0x7a, 0x7a, 0x4b, 0x53, 0x71, 0x5d, 0xeb, 0xe0, 0x30, 0xea, 0x25, 0x74, 0x13, 0xae,
	0x2d, 0x5c, 0x17, 0xa1, 0x11, 0x07, 0x74, 0xda, 0xdd, 0xe7, 0x07, 0x8b, 0x23, 0xac, 0xa3, 0x0a,
	0x5c, 0x5f, 0x0c, 0x10, 0x21, 0x2e, 0xa3, 0xdb, 0x70, 0x33, 0xc8, 0xa1, 0x1e, 0xe9, 0xcf, 0x5a,
	0x5d, 0xad, 0x83, 0x8f, 0x38, 0x32, 0x0c, 0xb3, 0x71, 0x0e, 0xc8, 0xc7, 0x88, 0x48, 0x45, 0xb4,
	0x09, 0x95, 0x30, 0xd7, 0x79, 0xa1, 0xae, 0xa0, 0x3b, 0x70, 0xeb, 0x23, 0x28, 0x11, 0x4c, 0x61,
	0xd2, 0xf0, 0x8b, 0x53, 0xdb, 0x4d, 0x15, 0xeb, 0xf5, 0x66, 0x13, 0xab, 0xdd, 0x6e, 0x18, 0xe6,
	0x2a, 0x3b, 0xf9, 0xc2, 0x75, 0x11, 0xa0, 0x84, 0xae, 0xc1, 0x15, 0x7e, 0x8f, 0x75, 0xad, 0xf1,
	0x2c, 0x56, 0x16, 0xd7, 0xd0, 0x75, 0x50, 0xe6, 0x17, 0x05, 0xf5, 0xfa, 0xbd, 0xca, 0x59, 0x5d,
	0xb3, 0x9f, 0x24, 0x28, 0x0d, 0x89, 0xce, 0x9e, 0xbc, 0xc4, 0x4a, 0xf3, 0x49, 0xbd, 0xb5, 0x2f,
	0x4b, 0x3b, 0x2f, 0x20, 0x1f, 0x20, 0xb0, 0xd3, 0x47, 0x7b, 0xc1, 0xb3, 0xc5, 0x08, 0xe3, 0xf1,
	0xc4, 0x1a, 0xf6, 0x0d, 0x4a, 0x50, 0x31, 0xf6, 0xfb, 0x46, 0xfc, 0xcf, 0x50, 0x3a, 0xc7, 0x5f,
	0x5d, 0xda, 0x92, 0xbe, 0x90, 0x1e, 0x77, 0x7e, 0xff, 0x50, 0x96, 0xde, 0x7d, 0x28, 0x4b, 0x7f,
	0x7d, 0x28, 0x4b, 0xbf, 0x9c, 0x96, 0x97, 0xde, 0x9d, 0x96, 0x97, 0xfe, 0x3c, 0x2d, 0x2f, 0xbd,
	0xf8, 0x8a, 0xbf, 0xe9, 0x63, 0xe3, 0x0d, 0x71, 0x6b, 0xb6, 0x3b, 0xd8, 0x3e, 0x33, 0xb7, 0x8f,
	0xc7, 0xf7, 0x89, 0x35, 0x18, 0x5a, 0x64, 0x9b, 0xfd, 0xa7, 0x39, 0x70, 0xb7, 0x9d, 0x97, 0xdb,
	0x3c, 0xc9, 0xc0, 0x7e, 0x99, 0xe6, 0x1f, 0x5f, 0xfe, 0x13, 0x00, 0x00, 0xff, 0xff, 0xe4, 0xec,
	0x81, 0xd4, 0x8b, 0x0e, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// DockerVMRpcClient is the client API for DockerVMRpc service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type DockerVMRpcClient interface {
	DockerVMCommunicate(ctx context.Context, opts ...grpc.CallOption) (DockerVMRpc_DockerVMCommunicateClient, error)
}

type dockerVMRpcClient struct {
	cc *grpc.ClientConn
}

func NewDockerVMRpcClient(cc *grpc.ClientConn) DockerVMRpcClient {
	return &dockerVMRpcClient{cc}
}

func (c *dockerVMRpcClient) DockerVMCommunicate(ctx context.Context, opts ...grpc.CallOption) (DockerVMRpc_DockerVMCommunicateClient, error) {
	stream, err := c.cc.NewStream(ctx, &_DockerVMRpc_serviceDesc.Streams[0], "/proto.DockerVMRpc/DockerVMCommunicate", opts...)
	if err != nil {
		return nil, err
	}
	x := &dockerVMRpcDockerVMCommunicateClient{stream}
	return x, nil
}

type DockerVMRpc_DockerVMCommunicateClient interface {
	Send(*DockerVMMessage) error
	Recv() (*DockerVMMessage, error)
	grpc.ClientStream
}

type dockerVMRpcDockerVMCommunicateClient struct {
	grpc.ClientStream
}

func (x *dockerVMRpcDockerVMCommunicateClient) Send(m *DockerVMMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *dockerVMRpcDockerVMCommunicateClient) Recv() (*DockerVMMessage, error) {
	m := new(DockerVMMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DockerVMRpcServer is the server API for DockerVMRpc service.
type DockerVMRpcServer interface {
	DockerVMCommunicate(DockerVMRpc_DockerVMCommunicateServer) error
}

// UnimplementedDockerVMRpcServer can be embedded to have forward compatible implementations.
type UnimplementedDockerVMRpcServer struct {
}

func (*UnimplementedDockerVMRpcServer) DockerVMCommunicate(srv DockerVMRpc_DockerVMCommunicateServer) error {
	return status.Errorf(codes.Unimplemented, "method DockerVMCommunicate not implemented")
}

func RegisterDockerVMRpcServer(s *grpc.Server, srv DockerVMRpcServer) {
	s.RegisterService(&_DockerVMRpc_serviceDesc, srv)
}

func _DockerVMRpc_DockerVMCommunicate_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DockerVMRpcServer).DockerVMCommunicate(&dockerVMRpcDockerVMCommunicateServer{stream})
}

type DockerVMRpc_DockerVMCommunicateServer interface {
	Send(*DockerVMMessage) error
	Recv() (*DockerVMMessage, error)
	grpc.ServerStream
}

type dockerVMRpcDockerVMCommunicateServer struct {
	grpc.ServerStream
}

func (x *dockerVMRpcDockerVMCommunicateServer) Send(m *DockerVMMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *dockerVMRpcDockerVMCommunicateServer) Recv() (*DockerVMMessage, error) {
	m := new(DockerVMMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _DockerVMRpc_serviceDesc = grpc.ServiceDesc{
	ServiceName: "proto.DockerVMRpc",
	HandlerType: (*DockerVMRpcServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "DockerVMCommunicate",
			Handler:       _DockerVMRpc_DockerVMCommunicate_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "dockervm_message.proto",
}

func (m *DockerVMMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerVMMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DockerVMMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x3a
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.SysCallMessage != nil {
		{
			size, err := m.SysCallMessage.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.CrossContext != nil {
		{
			size, err := m.CrossContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SysCallMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysCallMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysCallMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for k := range m.Payload {
			v := m.Payload[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Code != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CrossInfo != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.CrossInfo))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProcessName) > 0 {
		i -= len(m.ProcessName)
		copy(dAtA[i:], m.ProcessName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ProcessName)))
		i--
		dAtA[i] = 0x12
	}
	if m.CurrentDepth != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.CurrentDepth))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x32
	}
	if m.TxContext != nil {
		{
			size, err := m.TxContext.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Parameters) > 0 {
		for k := range m.Parameters {
			v := m.Parameters[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxContext) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxContext) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxContext) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ReadMap) > 0 {
		for k := range m.ReadMap {
			v := m.ReadMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.WriteMap) > 0 {
		for k := range m.WriteMap {
			v := m.WriteMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TxResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxDuration != nil {
		{
			size, err := m.TxDuration.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if len(m.ReadMap) > 0 {
		for k := range m.ReadMap {
			v := m.ReadMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.WriteMap) > 0 {
		for k := range m.WriteMap {
			v := m.WriteMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Code != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.Code))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DockerContractEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerContractEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DockerContractEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Data[iNdEx])
			copy(dAtA[i:], m.Data[iNdEx])
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Data[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CallContractRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CallContractRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CallContractRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for k := range m.Args {
			v := m.Args[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContractMethod) > 0 {
		i -= len(m.ContractMethod)
		copy(dAtA[i:], m.ContractMethod)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractMethod)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Events) > 0 {
		for iNdEx := len(m.Events) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Events[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ReadMap) > 0 {
		for k := range m.ReadMap {
			v := m.ReadMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.WriteMap) > 0 {
		for k := range m.WriteMap {
			v := m.WriteMap[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintDockervmMessage(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintDockervmMessage(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintDockervmMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Event) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Event) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Event) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		for iNdEx := len(m.Data) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Data[iNdEx])
			copy(dAtA[i:], m.Data[iNdEx])
			i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Data[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Topic) > 0 {
		i -= len(m.Topic)
		copy(dAtA[i:], m.Topic)
		i = encodeVarintDockervmMessage(dAtA, i, uint64(len(m.Topic)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxDuration) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxDuration) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxDuration) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CrossCallTime != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.CrossCallTime))
		i--
		dAtA[i] = 0x10
	}
	if m.CrossCallCnt != 0 {
		i = encodeVarintDockervmMessage(dAtA, i, uint64(m.CrossCallCnt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintDockervmMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovDockervmMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *DockerVMMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovDockervmMessage(uint64(m.Type))
	}
	if m.CrossContext != nil {
		l = m.CrossContext.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.SysCallMessage != nil {
		l = m.SysCallMessage.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	return n
}

func (m *SysCallMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Code != 0 {
		n += 1 + sovDockervmMessage(uint64(m.Code))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.Payload) > 0 {
		for k, v := range m.Payload {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *CrossContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CurrentDepth != 0 {
		n += 1 + sovDockervmMessage(uint64(m.CurrentDepth))
	}
	l = len(m.ProcessName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.CrossInfo != 0 {
		n += 1 + sovDockervmMessage(uint64(m.CrossInfo))
	}
	return n
}

func (m *TxRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.Parameters) > 0 {
		for k, v := range m.Parameters {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if m.TxContext != nil {
		l = m.TxContext.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	return n
}

func (m *TxContext) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.WriteMap) > 0 {
		for k, v := range m.WriteMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ReadMap) > 0 {
		for k, v := range m.ReadMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TxResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.Code != 0 {
		n += 1 + sovDockervmMessage(uint64(m.Code))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.WriteMap) > 0 {
		for k, v := range m.WriteMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ReadMap) > 0 {
		for k, v := range m.ReadMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovDockervmMessage(uint64(l))
		}
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if m.TxDuration != nil {
		l = m.TxDuration.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	return n
}

func (m *DockerContractEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, s := range m.Data {
			l = len(s)
			n += 1 + l + sovDockervmMessage(uint64(l))
		}
	}
	return n
}

func (m *CallContractRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ContractMethod)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.Args) > 0 {
		for k, v := range m.Args {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovDockervmMessage(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	return n
}

func (m *ContractResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.WriteMap) > 0 {
		for k, v := range m.WriteMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.ReadMap) > 0 {
		for k, v := range m.ReadMap {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovDockervmMessage(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovDockervmMessage(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovDockervmMessage(uint64(mapEntrySize))
		}
	}
	if len(m.Events) > 0 {
		for _, e := range m.Events {
			l = e.Size()
			n += 1 + l + sovDockervmMessage(uint64(l))
		}
	}
	return n
}

func (m *Event) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Topic)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovDockervmMessage(uint64(l))
	}
	if len(m.Data) > 0 {
		for _, s := range m.Data {
			l = len(s)
			n += 1 + l + sovDockervmMessage(uint64(l))
		}
	}
	return n
}

func (m *TxDuration) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CrossCallCnt != 0 {
		n += 1 + sovDockervmMessage(uint64(m.CrossCallCnt))
	}
	if m.CrossCallTime != 0 {
		n += 1 + sovDockervmMessage(uint64(m.CrossCallTime))
	}
	return n
}

func sovDockervmMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozDockervmMessage(x uint64) (n int) {
	return sovDockervmMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *DockerVMMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerVMMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerVMMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= DockerVMType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.CrossContext == nil {
				m.CrossContext = &CrossContext{}
			}
			if err := m.CrossContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SysCallMessage", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SysCallMessage == nil {
				m.SysCallMessage = &SysCallMessage{}
			}
			if err := m.SysCallMessage.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Request == nil {
				m.Request = &TxRequest{}
			}
			if err := m.Request.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &TxResponse{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SysCallMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysCallMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysCallMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= DockerVMCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Payload[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentDepth", wireType)
			}
			m.CurrentDepth = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentDepth |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProcessName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProcessName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossInfo", wireType)
			}
			m.CrossInfo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossInfo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Parameters == nil {
				m.Parameters = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Parameters[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxContext", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxContext == nil {
				m.TxContext = &TxContext{}
			}
			if err := m.TxContext.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxContext) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxContext: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxContext: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteMap == nil {
				m.WriteMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WriteMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadMap == nil {
				m.ReadMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadMap[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			m.Code = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Code |= DockerVMCode(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteMap == nil {
				m.WriteMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WriteMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadMap == nil {
				m.ReadMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &DockerContractEvent{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxDuration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TxDuration == nil {
				m.TxDuration = &TxDuration{}
			}
			if err := m.TxDuration.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerContractEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerContractEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerContractEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallContractRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallContractRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallContractRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractMethod", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractMethod = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Args[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &Response{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WriteMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WriteMap == nil {
				m.WriteMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.WriteMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadMap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ReadMap == nil {
				m.ReadMap = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowDockervmMessage
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowDockervmMessage
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipDockervmMessage(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthDockervmMessage
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ReadMap[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Events", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Events = append(m.Events, &Event{})
			if err := m.Events[len(m.Events)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Event) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Event: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Event: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Topic", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Topic = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxDuration) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxDuration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxDuration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCallCnt", wireType)
			}
			m.CrossCallCnt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossCallCnt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossCallTime", wireType)
			}
			m.CrossCallTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CrossCallTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipDockervmMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthDockervmMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipDockervmMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowDockervmMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowDockervmMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthDockervmMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupDockervmMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthDockervmMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthDockervmMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowDockervmMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupDockervmMessage = fmt.Errorf("proto: unexpected end of group")
)
