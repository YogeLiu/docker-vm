// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/chainedbft/chainedbft.proto

package chainedbft

import (
	common "chainmaker.org/chainmaker/pb-go/v2/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// response status
type BlockFetchStatus int32

const (
	BlockFetchStatus_SUCCEEDED         BlockFetchStatus = 0
	BlockFetchStatus_NOT_ENOUGH_BLOCKS BlockFetchStatus = 1
)

var BlockFetchStatus_name = map[int32]string{
	0: "SUCCEEDED",
	1: "NOT_ENOUGH_BLOCKS",
}

var BlockFetchStatus_value = map[string]int32{
	"SUCCEEDED":         0,
	"NOT_ENOUGH_BLOCKS": 1,
}

func (x BlockFetchStatus) String() string {
	return proto.EnumName(BlockFetchStatus_name, int32(x))
}

func (BlockFetchStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{0}
}

type ConsStateType int32

const (
	// new height
	ConsStateType_NEW_HEIGHT ConsStateType = 0
	// new level
	ConsStateType_NEW_LEVEL ConsStateType = 1
	// propose
	ConsStateType_PROPOSE ConsStateType = 2
	// vote
	ConsStateType_VOTE ConsStateType = 3
	// pacemaker of the consensus
	ConsStateType_PACEMAKER ConsStateType = 4
)

var ConsStateType_name = map[int32]string{
	0: "NEW_HEIGHT",
	1: "NEW_LEVEL",
	2: "PROPOSE",
	3: "VOTE",
	4: "PACEMAKER",
}

var ConsStateType_value = map[string]int32{
	"NEW_HEIGHT": 0,
	"NEW_LEVEL":  1,
	"PROPOSE":    2,
	"VOTE":       3,
	"PACEMAKER":  4,
}

func (x ConsStateType) String() string {
	return proto.EnumName(ConsStateType_name, int32(x))
}

func (ConsStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{1}
}

type MessageType int32

const (
	MessageType_PROPOSAL_MESSAGE         MessageType = 0
	MessageType_VOTE_MESSAGE             MessageType = 1
	MessageType_BLOCK_FETCH_MESSAGE      MessageType = 2
	MessageType_BLOCK_FETCH_RESP_MESSAGE MessageType = 3
)

var MessageType_name = map[int32]string{
	0: "PROPOSAL_MESSAGE",
	1: "VOTE_MESSAGE",
	2: "BLOCK_FETCH_MESSAGE",
	3: "BLOCK_FETCH_RESP_MESSAGE",
}

var MessageType_value = map[string]int32{
	"PROPOSAL_MESSAGE":         0,
	"VOTE_MESSAGE":             1,
	"BLOCK_FETCH_MESSAGE":      2,
	"BLOCK_FETCH_RESP_MESSAGE": 3,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{2}
}

type QuorumCert struct {
	// block id of the qc block
	BlockId []byte `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	// block height of the qc block
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// consensus level of the qc block
	Level uint64 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	// Whether to vote timeout of the qc block
	NewView bool `protobuf:"varint,4,opt,name=new_view,json=newView,proto3" json:"new_view,omitempty"`
	// the id of the epoch
	EpochId uint64      `protobuf:"varint,5,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	Votes   []*VoteData `protobuf:"bytes,6,rep,name=votes,proto3" json:"votes,omitempty"`
}

func (m *QuorumCert) Reset()         { *m = QuorumCert{} }
func (m *QuorumCert) String() string { return proto.CompactTextString(m) }
func (*QuorumCert) ProtoMessage()    {}
func (*QuorumCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{0}
}
func (m *QuorumCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumCert.Merge(m, src)
}
func (m *QuorumCert) XXX_Size() int {
	return m.Size()
}
func (m *QuorumCert) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumCert.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumCert proto.InternalMessageInfo

func (m *QuorumCert) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *QuorumCert) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *QuorumCert) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *QuorumCert) GetNewView() bool {
	if m != nil {
		return m.NewView
	}
	return false
}

func (m *QuorumCert) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *QuorumCert) GetVotes() []*VoteData {
	if m != nil {
		return m.Votes
	}
	return nil
}

type ConsensusInfo struct {
	// block's qc info
	Qc *QuorumCert `protobuf:"bytes,1,opt,name=qc,proto3" json:"qc,omitempty"`
}

func (m *ConsensusInfo) Reset()         { *m = ConsensusInfo{} }
func (m *ConsensusInfo) String() string { return proto.CompactTextString(m) }
func (*ConsensusInfo) ProtoMessage()    {}
func (*ConsensusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{1}
}
func (m *ConsensusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusInfo.Merge(m, src)
}
func (m *ConsensusInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusInfo proto.InternalMessageInfo

func (m *ConsensusInfo) GetQc() *QuorumCert {
	if m != nil {
		return m.Qc
	}
	return nil
}

type SyncInfo struct {
	// highest qc of the vote node
	HighestQc *QuorumCert `protobuf:"bytes,1,opt,name=highest_qc,json=highestQc,proto3" json:"highest_qc,omitempty"`
	// highest tc of the vote node
	HighestTc *QuorumCert `protobuf:"bytes,2,opt,name=highest_tc,json=highestTc,proto3" json:"highest_tc,omitempty"`
	// Latest timeout consensus level
	HighestTcLevel uint64 `protobuf:"varint,3,opt,name=highest_tc_level,json=highestTcLevel,proto3" json:"highest_tc_level,omitempty"`
}

func (m *SyncInfo) Reset()         { *m = SyncInfo{} }
func (m *SyncInfo) String() string { return proto.CompactTextString(m) }
func (*SyncInfo) ProtoMessage()    {}
func (*SyncInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{2}
}
func (m *SyncInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncInfo.Merge(m, src)
}
func (m *SyncInfo) XXX_Size() int {
	return m.Size()
}
func (m *SyncInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SyncInfo proto.InternalMessageInfo

func (m *SyncInfo) GetHighestQc() *QuorumCert {
	if m != nil {
		return m.HighestQc
	}
	return nil
}

func (m *SyncInfo) GetHighestTc() *QuorumCert {
	if m != nil {
		return m.HighestTc
	}
	return nil
}

func (m *SyncInfo) GetHighestTcLevel() uint64 {
	if m != nil {
		return m.HighestTcLevel
	}
	return 0
}

type ProposalData struct {
	// block info of the proposal
	Block *common.Block `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	// height of the proposal
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// consensus level of the proposal
	Level uint64 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	// proposer of the proposal
	Proposer []byte `protobuf:"bytes,4,opt,name=proposer,proto3" json:"proposer,omitempty"`
	// index of the proposer in consensus nodes
	ProposerIdx uint64 `protobuf:"varint,5,opt,name=proposer_idx,json=proposerIdx,proto3" json:"proposer_idx,omitempty"`
	// the id of the epoch
	EpochId uint64 `protobuf:"varint,6,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// the qc info of the parent's block in the proposal
	JustifyQc *QuorumCert `protobuf:"bytes,7,opt,name=justify_qc,json=justifyQc,proto3" json:"justify_qc,omitempty"`
}

func (m *ProposalData) Reset()         { *m = ProposalData{} }
func (m *ProposalData) String() string { return proto.CompactTextString(m) }
func (*ProposalData) ProtoMessage()    {}
func (*ProposalData) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{3}
}
func (m *ProposalData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalData.Merge(m, src)
}
func (m *ProposalData) XXX_Size() int {
	return m.Size()
}
func (m *ProposalData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalData.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalData proto.InternalMessageInfo

func (m *ProposalData) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *ProposalData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ProposalData) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ProposalData) GetProposer() []byte {
	if m != nil {
		return m.Proposer
	}
	return nil
}

func (m *ProposalData) GetProposerIdx() uint64 {
	if m != nil {
		return m.ProposerIdx
	}
	return 0
}

func (m *ProposalData) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *ProposalData) GetJustifyQc() *QuorumCert {
	if m != nil {
		return m.JustifyQc
	}
	return nil
}

type ProposalMsg struct {
	// proposal data
	ProposalData *ProposalData `protobuf:"bytes,1,opt,name=proposal_data,json=proposalData,proto3" json:"proposal_data,omitempty"`
	// qc info of the propose node
	SyncInfo *SyncInfo `protobuf:"bytes,2,opt,name=sync_info,json=syncInfo,proto3" json:"sync_info,omitempty"`
}

func (m *ProposalMsg) Reset()         { *m = ProposalMsg{} }
func (m *ProposalMsg) String() string { return proto.CompactTextString(m) }
func (*ProposalMsg) ProtoMessage()    {}
func (*ProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{4}
}
func (m *ProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalMsg.Merge(m, src)
}
func (m *ProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *ProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalMsg proto.InternalMessageInfo

func (m *ProposalMsg) GetProposalData() *ProposalData {
	if m != nil {
		return m.ProposalData
	}
	return nil
}

func (m *ProposalMsg) GetSyncInfo() *SyncInfo {
	if m != nil {
		return m.SyncInfo
	}
	return nil
}

type VoteData struct {
	// block id of the vote block
	BlockId []byte `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	// block height of the vote block
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// consensus level of the vote block
	Level uint64 `protobuf:"varint,3,opt,name=level,proto3" json:"level,omitempty"`
	// voter of the voteInfo
	Author []byte `protobuf:"bytes,4,opt,name=author,proto3" json:"author,omitempty"`
	// index of the voter in consensus nodes
	AuthorIdx uint64 `protobuf:"varint,5,opt,name=author_idx,json=authorIdx,proto3" json:"author_idx,omitempty"`
	// Whether to vote timeout of the block
	NewView bool `protobuf:"varint,6,opt,name=new_view,json=newView,proto3" json:"new_view,omitempty"`
	// the id of the epoch
	EpochId uint64 `protobuf:"varint,7,opt,name=epoch_id,json=epochId,proto3" json:"epoch_id,omitempty"`
	// signature of the vote
	Signature *common.EndorsementEntry `protobuf:"bytes,8,opt,name=signature,proto3" json:"signature,omitempty"`
}

func (m *VoteData) Reset()         { *m = VoteData{} }
func (m *VoteData) String() string { return proto.CompactTextString(m) }
func (*VoteData) ProtoMessage()    {}
func (*VoteData) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{5}
}
func (m *VoteData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteData.Merge(m, src)
}
func (m *VoteData) XXX_Size() int {
	return m.Size()
}
func (m *VoteData) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteData.DiscardUnknown(m)
}

var xxx_messageInfo_VoteData proto.InternalMessageInfo

func (m *VoteData) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *VoteData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteData) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *VoteData) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *VoteData) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *VoteData) GetNewView() bool {
	if m != nil {
		return m.NewView
	}
	return false
}

func (m *VoteData) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *VoteData) GetSignature() *common.EndorsementEntry {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VoteMsg struct {
	// data of the vote
	VoteData *VoteData `protobuf:"bytes,1,opt,name=vote_data,json=voteData,proto3" json:"vote_data,omitempty"`
	// qc info in the vote
	SyncInfo *SyncInfo `protobuf:"bytes,2,opt,name=sync_info,json=syncInfo,proto3" json:"sync_info,omitempty"`
}

func (m *VoteMsg) Reset()         { *m = VoteMsg{} }
func (m *VoteMsg) String() string { return proto.CompactTextString(m) }
func (*VoteMsg) ProtoMessage()    {}
func (*VoteMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{6}
}
func (m *VoteMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteMsg.Merge(m, src)
}
func (m *VoteMsg) XXX_Size() int {
	return m.Size()
}
func (m *VoteMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteMsg.DiscardUnknown(m)
}

var xxx_messageInfo_VoteMsg proto.InternalMessageInfo

func (m *VoteMsg) GetVoteData() *VoteData {
	if m != nil {
		return m.VoteData
	}
	return nil
}

func (m *VoteMsg) GetSyncInfo() *SyncInfo {
	if m != nil {
		return m.SyncInfo
	}
	return nil
}

type BlockFetchMsg struct {
	// block id of the latest know block in request node
	BlockId []byte `protobuf:"bytes,1,opt,name=block_id,json=blockId,proto3" json:"block_id,omitempty"`
	// block height of the latest know block in request node
	Height uint64 `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	// fetch block num
	NumBlocks uint64 `protobuf:"varint,3,opt,name=num_blocks,json=numBlocks,proto3" json:"num_blocks,omitempty"`
	// index of the request node;
	AuthorIdx uint64 `protobuf:"varint,4,opt,name=author_idx,json=authorIdx,proto3" json:"author_idx,omitempty"`
	// unique id of the request
	ReqId uint64 `protobuf:"varint,5,opt,name=req_id,json=reqId,proto3" json:"req_id,omitempty"`
	// id of the commit block in request node
	CommitBlock []byte `protobuf:"bytes,6,opt,name=commit_block,json=commitBlock,proto3" json:"commit_block,omitempty"`
	// id of the locked block in request node
	LockedBLock []byte `protobuf:"bytes,7,opt,name=locked_bLock,json=lockedBLock,proto3" json:"locked_bLock,omitempty"`
}

func (m *BlockFetchMsg) Reset()         { *m = BlockFetchMsg{} }
func (m *BlockFetchMsg) String() string { return proto.CompactTextString(m) }
func (*BlockFetchMsg) ProtoMessage()    {}
func (*BlockFetchMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{7}
}
func (m *BlockFetchMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockFetchMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockFetchMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockFetchMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockFetchMsg.Merge(m, src)
}
func (m *BlockFetchMsg) XXX_Size() int {
	return m.Size()
}
func (m *BlockFetchMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockFetchMsg.DiscardUnknown(m)
}

var xxx_messageInfo_BlockFetchMsg proto.InternalMessageInfo

func (m *BlockFetchMsg) GetBlockId() []byte {
	if m != nil {
		return m.BlockId
	}
	return nil
}

func (m *BlockFetchMsg) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockFetchMsg) GetNumBlocks() uint64 {
	if m != nil {
		return m.NumBlocks
	}
	return 0
}

func (m *BlockFetchMsg) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *BlockFetchMsg) GetReqId() uint64 {
	if m != nil {
		return m.ReqId
	}
	return 0
}

func (m *BlockFetchMsg) GetCommitBlock() []byte {
	if m != nil {
		return m.CommitBlock
	}
	return nil
}

func (m *BlockFetchMsg) GetLockedBLock() []byte {
	if m != nil {
		return m.LockedBLock
	}
	return nil
}

type BlockPair struct {
	Block *common.Block `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Qc    *QuorumCert   `protobuf:"bytes,2,opt,name=qc,proto3" json:"qc,omitempty"`
}

func (m *BlockPair) Reset()         { *m = BlockPair{} }
func (m *BlockPair) String() string { return proto.CompactTextString(m) }
func (*BlockPair) ProtoMessage()    {}
func (*BlockPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{8}
}
func (m *BlockPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockPair.Merge(m, src)
}
func (m *BlockPair) XXX_Size() int {
	return m.Size()
}
func (m *BlockPair) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockPair.DiscardUnknown(m)
}

var xxx_messageInfo_BlockPair proto.InternalMessageInfo

func (m *BlockPair) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockPair) GetQc() *QuorumCert {
	if m != nil {
		return m.Qc
	}
	return nil
}

type BlockFetchRespMsg struct {
	// response status
	Status BlockFetchStatus `protobuf:"varint,1,opt,name=status,proto3,enum=chainedbft.BlockFetchStatus" json:"status,omitempty"`
	// block in response
	Blocks []*BlockPair `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
	// index of the response node
	AuthorIdx uint64 `protobuf:"varint,3,opt,name=author_idx,json=authorIdx,proto3" json:"author_idx,omitempty"`
	// unique id of the response which is the request id
	RespId uint64 `protobuf:"varint,4,opt,name=resp_id,json=respId,proto3" json:"resp_id,omitempty"`
}

func (m *BlockFetchRespMsg) Reset()         { *m = BlockFetchRespMsg{} }
func (m *BlockFetchRespMsg) String() string { return proto.CompactTextString(m) }
func (*BlockFetchRespMsg) ProtoMessage()    {}
func (*BlockFetchRespMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{9}
}
func (m *BlockFetchRespMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockFetchRespMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockFetchRespMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockFetchRespMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockFetchRespMsg.Merge(m, src)
}
func (m *BlockFetchRespMsg) XXX_Size() int {
	return m.Size()
}
func (m *BlockFetchRespMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockFetchRespMsg.DiscardUnknown(m)
}

var xxx_messageInfo_BlockFetchRespMsg proto.InternalMessageInfo

func (m *BlockFetchRespMsg) GetStatus() BlockFetchStatus {
	if m != nil {
		return m.Status
	}
	return BlockFetchStatus_SUCCEEDED
}

func (m *BlockFetchRespMsg) GetBlocks() []*BlockPair {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *BlockFetchRespMsg) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *BlockFetchRespMsg) GetRespId() uint64 {
	if m != nil {
		return m.RespId
	}
	return 0
}

type ConsensusPayload struct {
	Type MessageType `protobuf:"varint,1,opt,name=type,proto3,enum=chainedbft.MessageType" json:"type,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*ConsensusPayload_ProposalMsg
	//	*ConsensusPayload_VoteMsg
	//	*ConsensusPayload_BlockFetchMsg
	//	*ConsensusPayload_BlockFetchRespMsg
	Data isConsensusPayload_Data `protobuf_oneof:"data"`
}

func (m *ConsensusPayload) Reset()         { *m = ConsensusPayload{} }
func (m *ConsensusPayload) String() string { return proto.CompactTextString(m) }
func (*ConsensusPayload) ProtoMessage()    {}
func (*ConsensusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{10}
}
func (m *ConsensusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusPayload.Merge(m, src)
}
func (m *ConsensusPayload) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusPayload proto.InternalMessageInfo

type isConsensusPayload_Data interface {
	isConsensusPayload_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsensusPayload_ProposalMsg struct {
	ProposalMsg *ProposalMsg `protobuf:"bytes,2,opt,name=proposal_msg,json=proposalMsg,proto3,oneof" json:"proposal_msg,omitempty"`
}
type ConsensusPayload_VoteMsg struct {
	VoteMsg *VoteMsg `protobuf:"bytes,3,opt,name=vote_msg,json=voteMsg,proto3,oneof" json:"vote_msg,omitempty"`
}
type ConsensusPayload_BlockFetchMsg struct {
	BlockFetchMsg *BlockFetchMsg `protobuf:"bytes,4,opt,name=block_fetch_msg,json=blockFetchMsg,proto3,oneof" json:"block_fetch_msg,omitempty"`
}
type ConsensusPayload_BlockFetchRespMsg struct {
	BlockFetchRespMsg *BlockFetchRespMsg `protobuf:"bytes,5,opt,name=block_fetch_resp_msg,json=blockFetchRespMsg,proto3,oneof" json:"block_fetch_resp_msg,omitempty"`
}

func (*ConsensusPayload_ProposalMsg) isConsensusPayload_Data()       {}
func (*ConsensusPayload_VoteMsg) isConsensusPayload_Data()           {}
func (*ConsensusPayload_BlockFetchMsg) isConsensusPayload_Data()     {}
func (*ConsensusPayload_BlockFetchRespMsg) isConsensusPayload_Data() {}

func (m *ConsensusPayload) GetData() isConsensusPayload_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ConsensusPayload) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_PROPOSAL_MESSAGE
}

func (m *ConsensusPayload) GetProposalMsg() *ProposalMsg {
	if x, ok := m.GetData().(*ConsensusPayload_ProposalMsg); ok {
		return x.ProposalMsg
	}
	return nil
}

func (m *ConsensusPayload) GetVoteMsg() *VoteMsg {
	if x, ok := m.GetData().(*ConsensusPayload_VoteMsg); ok {
		return x.VoteMsg
	}
	return nil
}

func (m *ConsensusPayload) GetBlockFetchMsg() *BlockFetchMsg {
	if x, ok := m.GetData().(*ConsensusPayload_BlockFetchMsg); ok {
		return x.BlockFetchMsg
	}
	return nil
}

func (m *ConsensusPayload) GetBlockFetchRespMsg() *BlockFetchRespMsg {
	if x, ok := m.GetData().(*ConsensusPayload_BlockFetchRespMsg); ok {
		return x.BlockFetchRespMsg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsensusPayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsensusPayload_ProposalMsg)(nil),
		(*ConsensusPayload_VoteMsg)(nil),
		(*ConsensusPayload_BlockFetchMsg)(nil),
		(*ConsensusPayload_BlockFetchRespMsg)(nil),
	}
}

type ConsensusMsg struct {
	Payload   *ConsensusPayload        `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	SignEntry *common.EndorsementEntry `protobuf:"bytes,2,opt,name=sign_entry,json=signEntry,proto3" json:"sign_entry,omitempty"`
}

func (m *ConsensusMsg) Reset()         { *m = ConsensusMsg{} }
func (m *ConsensusMsg) String() string { return proto.CompactTextString(m) }
func (*ConsensusMsg) ProtoMessage()    {}
func (*ConsensusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{11}
}
func (m *ConsensusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMsg.Merge(m, src)
}
func (m *ConsensusMsg) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMsg proto.InternalMessageInfo

func (m *ConsensusMsg) GetPayload() *ConsensusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ConsensusMsg) GetSignEntry() *common.EndorsementEntry {
	if m != nil {
		return m.SignEntry
	}
	return nil
}

type BuildProposal struct {
	Height     uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	PreHash    []byte `protobuf:"bytes,2,opt,name=pre_hash,json=preHash,proto3" json:"pre_hash,omitempty"`
	IsProposer bool   `protobuf:"varint,3,opt,name=is_proposer,json=isProposer,proto3" json:"is_proposer,omitempty"`
}

func (m *BuildProposal) Reset()         { *m = BuildProposal{} }
func (m *BuildProposal) String() string { return proto.CompactTextString(m) }
func (*BuildProposal) ProtoMessage()    {}
func (*BuildProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{12}
}
func (m *BuildProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildProposal.Merge(m, src)
}
func (m *BuildProposal) XXX_Size() int {
	return m.Size()
}
func (m *BuildProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BuildProposal proto.InternalMessageInfo

func (m *BuildProposal) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BuildProposal) GetPreHash() []byte {
	if m != nil {
		return m.PreHash
	}
	return nil
}

func (m *BuildProposal) GetIsProposer() bool {
	if m != nil {
		return m.IsProposer
	}
	return false
}

type WalEntry struct {
	Msg               *ConsensusMsg `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	MsgType           MessageType   `protobuf:"varint,2,opt,name=msg_type,json=msgType,proto3,enum=chainedbft.MessageType" json:"msg_type,omitempty"`
	LastSnapshotIndex uint64        `protobuf:"varint,3,opt,name=last_snapshot_index,json=lastSnapshotIndex,proto3" json:"last_snapshot_index,omitempty"`
}

func (m *WalEntry) Reset()         { *m = WalEntry{} }
func (m *WalEntry) String() string { return proto.CompactTextString(m) }
func (*WalEntry) ProtoMessage()    {}
func (*WalEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{13}
}
func (m *WalEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WalEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WalEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WalEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WalEntry.Merge(m, src)
}
func (m *WalEntry) XXX_Size() int {
	return m.Size()
}
func (m *WalEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_WalEntry.DiscardUnknown(m)
}

var xxx_messageInfo_WalEntry proto.InternalMessageInfo

func (m *WalEntry) GetMsg() *ConsensusMsg {
	if m != nil {
		return m.Msg
	}
	return nil
}

func (m *WalEntry) GetMsgType() MessageType {
	if m != nil {
		return m.MsgType
	}
	return MessageType_PROPOSAL_MESSAGE
}

func (m *WalEntry) GetLastSnapshotIndex() uint64 {
	if m != nil {
		return m.LastSnapshotIndex
	}
	return 0
}

func init() {
	proto.RegisterEnum("chainedbft.BlockFetchStatus", BlockFetchStatus_name, BlockFetchStatus_value)
	proto.RegisterEnum("chainedbft.ConsStateType", ConsStateType_name, ConsStateType_value)
	proto.RegisterEnum("chainedbft.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*QuorumCert)(nil), "chainedbft.QuorumCert")
	proto.RegisterType((*ConsensusInfo)(nil), "chainedbft.ConsensusInfo")
	proto.RegisterType((*SyncInfo)(nil), "chainedbft.SyncInfo")
	proto.RegisterType((*ProposalData)(nil), "chainedbft.ProposalData")
	proto.RegisterType((*ProposalMsg)(nil), "chainedbft.ProposalMsg")
	proto.RegisterType((*VoteData)(nil), "chainedbft.VoteData")
	proto.RegisterType((*VoteMsg)(nil), "chainedbft.VoteMsg")
	proto.RegisterType((*BlockFetchMsg)(nil), "chainedbft.BlockFetchMsg")
	proto.RegisterType((*BlockPair)(nil), "chainedbft.BlockPair")
	proto.RegisterType((*BlockFetchRespMsg)(nil), "chainedbft.BlockFetchRespMsg")
	proto.RegisterType((*ConsensusPayload)(nil), "chainedbft.ConsensusPayload")
	proto.RegisterType((*ConsensusMsg)(nil), "chainedbft.ConsensusMsg")
	proto.RegisterType((*BuildProposal)(nil), "chainedbft.BuildProposal")
	proto.RegisterType((*WalEntry)(nil), "chainedbft.WalEntry")
}

func init() {
	proto.RegisterFile("consensus/chainedbft/chainedbft.proto", fileDescriptor_4f12a9b7497e8ce5)
}

var fileDescriptor_4f12a9b7497e8ce5 = []byte{
	// 1223 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x96, 0xcd, 0x92, 0xda, 0xc6,
	0x13, 0xc0, 0x11, 0x5f, 0x82, 0x06, 0xfc, 0xd7, 0x8e, 0xd7, 0x5e, 0xec, 0xb2, 0xf9, 0x6f, 0x94,
	0x8a, 0x6b, 0x6b, 0x53, 0x86, 0x78, 0x13, 0xdb, 0x39, 0x24, 0x87, 0x05, 0xcb, 0x86, 0x32, 0x6b,
	0xb0, 0xc0, 0xeb, 0x54, 0x2e, 0x2a, 0x21, 0xcd, 0x4a, 0x8a, 0x41, 0xd2, 0x6a, 0x04, 0x6b, 0x4e,
	0x7e, 0x85, 0x9c, 0x73, 0xcc, 0x13, 0xe4, 0x96, 0x57, 0xc8, 0x29, 0xe5, 0x63, 0x2e, 0xa9, 0x4a,
	0xed, 0xbe, 0x41, 0x4e, 0x39, 0xa6, 0x66, 0x34, 0x02, 0x41, 0x88, 0x37, 0x71, 0xe5, 0xc4, 0x74,
	0x4f, 0x77, 0xcf, 0xcc, 0xaf, 0x3f, 0x10, 0x7c, 0x64, 0x78, 0x2e, 0xc1, 0x2e, 0x99, 0x92, 0x86,
	0x61, 0xeb, 0x8e, 0x8b, 0xcd, 0xd1, 0x49, 0x98, 0x58, 0xd6, 0xfd, 0xc0, 0x0b, 0x3d, 0x04, 0x4b,
	0xcd, 0x4d, 0x64, 0x78, 0x93, 0x89, 0xe7, 0x36, 0x46, 0x63, 0xcf, 0x78, 0x15, 0xed, 0xdf, 0xdc,
	0xe6, 0xba, 0x00, 0x9f, 0x4e, 0x31, 0xe1, 0x5e, 0xf2, 0x8f, 0x02, 0xc0, 0xf3, 0xa9, 0x17, 0x4c,
	0x27, 0x2d, 0x1c, 0x84, 0xe8, 0x06, 0x14, 0x98, 0x8f, 0xe6, 0x98, 0x55, 0x61, 0x57, 0xd8, 0x2b,
	0xab, 0x22, 0x93, 0x3b, 0x26, 0xba, 0x0e, 0x79, 0x1b, 0x3b, 0x96, 0x1d, 0x56, 0xd3, 0xbb, 0xc2,
	0x5e, 0x56, 0xe5, 0x12, 0xda, 0x86, 0xdc, 0x18, 0xcf, 0xf0, 0xb8, 0x9a, 0x61, 0xea, 0x48, 0xa0,
	0x81, 0x5c, 0x7c, 0xa6, 0xcd, 0x1c, 0x7c, 0x56, 0xcd, 0xee, 0x0a, 0x7b, 0x05, 0x55, 0x74, 0xf1,
	0xd9, 0xb1, 0x83, 0xcf, 0xe8, 0x16, 0xf6, 0x3d, 0xc3, 0xa6, 0x67, 0xe4, 0x98, 0x8f, 0xc8, 0xe4,
	0x8e, 0x89, 0xf6, 0x21, 0x37, 0xf3, 0x42, 0x4c, 0xaa, 0xf9, 0xdd, 0xcc, 0x5e, 0xe9, 0x60, 0xbb,
	0x9e, 0x78, 0xe5, 0xb1, 0x17, 0xe2, 0x47, 0x7a, 0xa8, 0xab, 0x91, 0x89, 0xfc, 0x10, 0x2a, 0xad,
	0x18, 0x4c, 0xc7, 0x3d, 0xf1, 0xd0, 0x1d, 0x48, 0x9f, 0x1a, 0xec, 0xd6, 0xa5, 0x83, 0xeb, 0x49,
	0xcf, 0xe5, 0xfb, 0xd4, 0xf4, 0xa9, 0x21, 0x7f, 0x2f, 0x40, 0x61, 0x30, 0x77, 0x0d, 0xe6, 0x74,
	0x1f, 0xc0, 0x76, 0x2c, 0x1b, 0x93, 0x50, 0xbb, 0xd4, 0xb9, 0xc8, 0x2d, 0x9f, 0x1b, 0x49, 0xb7,
	0xd0, 0x60, 0x40, 0x2e, 0x77, 0x1b, 0x1a, 0x68, 0x0f, 0xa4, 0xa5, 0x9b, 0x96, 0xc4, 0x76, 0x65,
	0x61, 0xd4, 0xa5, 0x5a, 0xf9, 0x77, 0x01, 0xca, 0xfd, 0xc0, 0xf3, 0x3d, 0xa2, 0x8f, 0xe9, 0xab,
	0xd1, 0x87, 0x90, 0x63, 0x99, 0xe0, 0x77, 0xac, 0xd4, 0xa3, 0x74, 0xd6, 0x9b, 0x54, 0xa9, 0x46,
	0x7b, 0xff, 0x32, 0x47, 0x37, 0xa1, 0xe0, 0xb3, 0x23, 0x70, 0xc0, 0x72, 0x54, 0x56, 0x17, 0x32,
	0xfa, 0x00, 0xca, 0xf1, 0x5a, 0x73, 0xcc, 0xd7, 0x3c, 0x51, 0xa5, 0x58, 0xd7, 0x31, 0x5f, 0xaf,
	0xe4, 0x31, 0xbf, 0x9a, 0xc7, 0xfb, 0x00, 0xdf, 0x4c, 0x49, 0xe8, 0x9c, 0xcc, 0x29, 0x55, 0xf1,
	0xdd, 0x78, 0xb8, 0xe5, 0x73, 0x43, 0x7e, 0x03, 0xa5, 0xf8, 0xcd, 0x47, 0xc4, 0x42, 0x5f, 0x42,
	0xc5, 0xe7, 0xa2, 0x66, 0xea, 0xa1, 0xce, 0x9f, 0x5e, 0x4d, 0x06, 0x4a, 0x32, 0x52, 0xcb, 0x7e,
	0x92, 0xd8, 0x3d, 0x28, 0x92, 0xb9, 0x6b, 0x68, 0x8e, 0x7b, 0xe2, 0xf1, 0x14, 0xad, 0x14, 0x54,
	0x5c, 0x03, 0x6a, 0x81, 0xf0, 0x95, 0xfc, 0x87, 0x00, 0x85, 0xb8, 0xce, 0xfe, 0xbb, 0x5e, 0xb8,
	0x0e, 0x79, 0x7d, 0x1a, 0xda, 0x5e, 0x4c, 0x99, 0x4b, 0xe8, 0x36, 0x40, 0xb4, 0x4a, 0x10, 0x2e,
	0x46, 0x1a, 0xce, 0x77, 0xd1, 0x42, 0xf9, 0xbf, 0x6f, 0x21, 0x71, 0x15, 0xfd, 0x03, 0x28, 0x12,
	0xc7, 0x72, 0xf5, 0x70, 0x1a, 0xe0, 0x6a, 0x21, 0x06, 0x16, 0xd5, 0x8a, 0xe2, 0x9a, 0x5e, 0x40,
	0xf0, 0x04, 0xbb, 0xa1, 0xe2, 0x86, 0xc1, 0x5c, 0x5d, 0x9a, 0xca, 0x1e, 0x88, 0xf4, 0xe5, 0x94,
	0xfb, 0x3d, 0x28, 0xd2, 0x16, 0x4b, 0x32, 0xdf, 0xdc, 0x89, 0x85, 0x59, 0xcc, 0xea, 0x3d, 0x58,
	0xff, 0x2a, 0x40, 0x85, 0x15, 0xef, 0x63, 0x1c, 0x1a, 0x36, 0x3d, 0xf7, 0x3d, 0x80, 0xdf, 0x06,
	0x70, 0xa7, 0x13, 0x8d, 0x99, 0x11, 0x4e, 0xbd, 0xe8, 0x4e, 0x27, 0x2c, 0x30, 0x59, 0x23, 0x9c,
	0x5d, 0x27, 0x7c, 0x0d, 0xf2, 0x01, 0x3e, 0x5d, 0xce, 0xa1, 0x5c, 0x80, 0x4f, 0x3b, 0x26, 0xad,
	0x7d, 0x0a, 0xcc, 0x09, 0xa3, 0xb8, 0x0c, 0x7e, 0x59, 0x2d, 0x45, 0x3a, 0x16, 0x99, 0x9a, 0xd0,
	0x5f, 0x6c, 0x6a, 0xa3, 0x2e, 0x35, 0x11, 0x23, 0x93, 0x48, 0xd7, 0xa4, 0x2a, 0xf9, 0x2b, 0x28,
	0x32, 0xdb, 0xbe, 0xee, 0x04, 0xff, 0xac, 0x7b, 0xa3, 0x01, 0x96, 0xbe, 0x74, 0x80, 0xfd, 0x20,
	0xc0, 0xd6, 0x92, 0x9c, 0x8a, 0x89, 0x4f, 0xe9, 0x7d, 0x06, 0x79, 0x12, 0xea, 0xe1, 0x94, 0xb0,
	0x33, 0xae, 0x1c, 0xdc, 0x4a, 0x46, 0x58, 0x9a, 0x0f, 0x98, 0x8d, 0xca, 0x6d, 0xd1, 0x5d, 0xc8,
	0x73, 0x78, 0x69, 0x36, 0x72, 0xaf, 0xfd, 0xc5, 0x8b, 0xde, 0x5f, 0xe5, 0x46, 0x6b, 0x40, 0x33,
	0xeb, 0x40, 0x77, 0x40, 0x0c, 0x30, 0xf1, 0x29, 0xd1, 0x08, 0x76, 0x9e, 0x8a, 0x1d, 0x53, 0xfe,
	0x39, 0x0d, 0xd2, 0x62, 0x5a, 0xf7, 0xf5, 0xf9, 0xd8, 0xd3, 0x4d, 0xf4, 0x31, 0x64, 0xc3, 0xb9,
	0x8f, 0xf9, 0x7d, 0x77, 0x92, 0x27, 0x1f, 0x61, 0x42, 0x74, 0x0b, 0x0f, 0xe7, 0x3e, 0x56, 0x99,
	0x11, 0xfa, 0x02, 0x16, 0xdd, 0xad, 0x4d, 0x88, 0xc5, 0x31, 0xed, 0x6c, 0x9a, 0x05, 0x47, 0xc4,
	0x6a, 0xa7, 0xe2, 0x59, 0x15, 0x8d, 0x92, 0x4f, 0x80, 0xd5, 0x2a, 0xf3, 0xcc, 0x30, 0xcf, 0xab,
	0xeb, 0x15, 0x1d, 0x79, 0x89, 0x33, 0xde, 0x04, 0x2d, 0xf8, 0x5f, 0x54, 0x8c, 0x27, 0x94, 0x1a,
	0x73, 0xcc, 0x32, 0xc7, 0x1b, 0x9b, 0xb9, 0x46, 0xee, 0x95, 0xd1, 0x4a, 0x45, 0xf7, 0x61, 0x3b,
	0x19, 0x84, 0xb1, 0xa1, 0x91, 0x72, 0x2c, 0xd2, 0xed, 0xcd, 0x91, 0x78, 0x42, 0xdb, 0x29, 0x75,
	0x6b, 0xb4, 0xae, 0x6c, 0xe6, 0x21, 0x4b, 0xdb, 0x52, 0x7e, 0x03, 0xe5, 0x05, 0x4f, 0x7a, 0xd2,
	0x03, 0x10, 0xfd, 0x08, 0x2b, 0x2f, 0xb1, 0x95, 0xf4, 0xaf, 0xa3, 0x57, 0x63, 0x63, 0xf4, 0x10,
	0x80, 0xce, 0x00, 0x0d, 0xd3, 0x79, 0xc0, 0xa1, 0x5e, 0x32, 0x2f, 0xd8, 0x52, 0x36, 0xa0, 0xd2,
	0x9c, 0x3a, 0x63, 0x33, 0x86, 0x9e, 0x68, 0x51, 0x61, 0xa5, 0x45, 0x6f, 0xd0, 0x7f, 0x19, 0xac,
	0xd9, 0x3a, 0xb1, 0x59, 0xfc, 0xb2, 0x2a, 0xfa, 0x01, 0x6e, 0xeb, 0xc4, 0x46, 0xff, 0x87, 0x92,
	0x43, 0xb4, 0xc5, 0x7f, 0x50, 0x86, 0x0d, 0x39, 0x70, 0x48, 0x9f, 0x6b, 0xe4, 0xef, 0x04, 0x28,
	0xbc, 0xd4, 0xc7, 0xec, 0x44, 0xb4, 0x0f, 0x19, 0xca, 0x6e, 0xc3, 0x9f, 0x40, 0x92, 0x84, 0x4a,
	0x8d, 0xd0, 0x01, 0x14, 0x26, 0xc4, 0xd2, 0x58, 0x79, 0xa5, 0xdf, 0x5d, 0x5e, 0xe2, 0x84, 0x58,
	0x74, 0x81, 0xea, 0x70, 0x75, 0xac, 0x93, 0x50, 0x23, 0xae, 0xee, 0x13, 0xdb, 0x0b, 0x35, 0xc7,
	0x35, 0x71, 0x5c, 0xe4, 0x5b, 0x74, 0x6b, 0xc0, 0x77, 0x3a, 0x74, 0x63, 0xff, 0x73, 0x90, 0xd6,
	0xdb, 0x0a, 0x55, 0xa0, 0x38, 0x78, 0xd1, 0x6a, 0x29, 0xca, 0x23, 0xe5, 0x91, 0x94, 0x42, 0xd7,
	0x60, 0xeb, 0x59, 0x6f, 0xa8, 0x29, 0xcf, 0x7a, 0x2f, 0x9e, 0xb4, 0xb5, 0x66, 0xb7, 0xd7, 0x7a,
	0x3a, 0x90, 0x84, 0xfd, 0x61, 0xf4, 0xe9, 0x42, 0x7d, 0xd8, 0x1d, 0xd0, 0x15, 0x80, 0x67, 0xca,
	0x4b, 0xad, 0xad, 0x74, 0x9e, 0xb4, 0x87, 0x52, 0x8a, 0x86, 0xa1, 0x72, 0x57, 0x39, 0x56, 0xba,
	0x92, 0x80, 0x4a, 0x20, 0xf6, 0xd5, 0x5e, 0xbf, 0x37, 0x50, 0xa4, 0x34, 0x2a, 0x40, 0xf6, 0xb8,
	0x37, 0x54, 0xa4, 0x0c, 0xb5, 0xea, 0x1f, 0xb6, 0x94, 0xa3, 0xc3, 0xa7, 0x8a, 0x2a, 0x65, 0xf7,
	0xc7, 0x50, 0x4a, 0xbc, 0x0b, 0x6d, 0x83, 0x14, 0x39, 0x1d, 0x76, 0xb5, 0x23, 0x65, 0x30, 0x38,
	0x7c, 0xa2, 0x48, 0x29, 0x24, 0x41, 0x99, 0x7a, 0x2f, 0x34, 0x02, 0xda, 0x81, 0xab, 0xec, 0x62,
	0xda, 0x63, 0x65, 0xd8, 0x6a, 0x2f, 0x36, 0xd2, 0xe8, 0x16, 0x54, 0x93, 0x1b, 0xaa, 0x32, 0xe8,
	0x2f, 0x76, 0x33, 0xcd, 0xf9, 0x4f, 0xe7, 0x35, 0xe1, 0xed, 0x79, 0x4d, 0xf8, 0xed, 0xbc, 0x26,
	0x7c, 0x7b, 0x51, 0x4b, 0xbd, 0xbd, 0xa8, 0xa5, 0x7e, 0xb9, 0xa8, 0xa5, 0xe0, 0x8e, 0x17, 0x58,
	0x11, 0xec, 0x89, 0xfe, 0x0a, 0x07, 0x75, 0x7f, 0x54, 0x5f, 0x7c, 0xc1, 0x26, 0x92, 0xf0, 0xf5,
	0xc3, 0x84, 0x8d, 0x17, 0x58, 0x8d, 0xa5, 0xd8, 0xf0, 0x47, 0x77, 0x2d, 0xaf, 0x31, 0x3b, 0x68,
	0x6c, 0xfa, 0xf4, 0x1d, 0xe5, 0xd9, 0xa7, 0xeb, 0xa7, 0x7f, 0x06, 0x00, 0x00, 0xff, 0xff, 0x13,
	0x8e, 0x59, 0x22, 0x19, 0x0b, 0x00, 0x00,
}

func (m *QuorumCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Votes) > 0 {
		for iNdEx := len(m.Votes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Votes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainedbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x28
	}
	if m.NewView {
		i--
		if m.NewView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Qc != nil {
		{
			size, err := m.Qc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighestTcLevel != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.HighestTcLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.HighestTc != nil {
		{
			size, err := m.HighestTc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HighestQc != nil {
		{
			size, err := m.HighestQc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JustifyQc != nil {
		{
			size, err := m.JustifyQc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x30
	}
	if m.ProposerIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.ProposerIdx))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SyncInfo != nil {
		{
			size, err := m.SyncInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalData != nil {
		{
			size, err := m.ProposalData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x38
	}
	if m.NewView {
		i--
		if m.NewView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SyncInfo != nil {
		{
			size, err := m.SyncInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VoteData != nil {
		{
			size, err := m.VoteData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockFetchMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockFetchMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockFetchMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LockedBLock) > 0 {
		i -= len(m.LockedBLock)
		copy(dAtA[i:], m.LockedBLock)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.LockedBLock)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.CommitBlock) > 0 {
		i -= len(m.CommitBlock)
		copy(dAtA[i:], m.CommitBlock)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.CommitBlock)))
		i--
		dAtA[i] = 0x32
	}
	if m.ReqId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.ReqId))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.NumBlocks != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.NumBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockId) > 0 {
		i -= len(m.BlockId)
		copy(dAtA[i:], m.BlockId)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Qc != nil {
		{
			size, err := m.Qc.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockFetchRespMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockFetchRespMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockFetchRespMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RespId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.RespId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainedbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusPayload_ProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_ProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalMsg != nil {
		{
			size, err := m.ProposalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_VoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteMsg != nil {
		{
			size, err := m.VoteMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_BlockFetchMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_BlockFetchMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockFetchMsg != nil {
		{
			size, err := m.BlockFetchMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_BlockFetchRespMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_BlockFetchRespMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockFetchRespMsg != nil {
		{
			size, err := m.BlockFetchRespMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignEntry != nil {
		{
			size, err := m.SignEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsProposer {
		i--
		if m.IsProposer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreHash) > 0 {
		i -= len(m.PreHash)
		copy(dAtA[i:], m.PreHash)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.PreHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *WalEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WalEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WalEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSnapshotIndex != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.LastSnapshotIndex))
		i--
		dAtA[i] = 0x18
	}
	if m.MsgType != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.MsgType))
		i--
		dAtA[i] = 0x10
	}
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainedbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainedbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QuorumCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	if m.NewView {
		n += 2
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if len(m.Votes) > 0 {
		for _, e := range m.Votes {
			l = e.Size()
			n += 1 + l + sovChainedbft(uint64(l))
		}
	}
	return n
}

func (m *ConsensusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Qc != nil {
		l = m.Qc.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *SyncInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HighestQc != nil {
		l = m.HighestQc.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.HighestTc != nil {
		l = m.HighestTc.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.HighestTcLevel != 0 {
		n += 1 + sovChainedbft(uint64(m.HighestTcLevel))
	}
	return n
}

func (m *ProposalData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.ProposerIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.ProposerIdx))
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if m.JustifyQc != nil {
		l = m.JustifyQc.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *ProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalData != nil {
		l = m.ProposalData.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SyncInfo != nil {
		l = m.SyncInfo.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *VoteData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	if m.NewView {
		n += 2
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteData != nil {
		l = m.VoteData.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SyncInfo != nil {
		l = m.SyncInfo.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BlockFetchMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockId)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.NumBlocks != 0 {
		n += 1 + sovChainedbft(uint64(m.NumBlocks))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	if m.ReqId != 0 {
		n += 1 + sovChainedbft(uint64(m.ReqId))
	}
	l = len(m.CommitBlock)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	l = len(m.LockedBLock)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BlockPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Qc != nil {
		l = m.Qc.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BlockFetchRespMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovChainedbft(uint64(m.Status))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovChainedbft(uint64(l))
		}
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	if m.RespId != 0 {
		n += 1 + sovChainedbft(uint64(m.RespId))
	}
	return n
}

func (m *ConsensusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovChainedbft(uint64(m.Type))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *ConsensusPayload_ProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalMsg != nil {
		l = m.ProposalMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteMsg != nil {
		l = m.VoteMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_BlockFetchMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockFetchMsg != nil {
		l = m.BlockFetchMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_BlockFetchRespMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockFetchRespMsg != nil {
		l = m.BlockFetchRespMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SignEntry != nil {
		l = m.SignEntry.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BuildProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	l = len(m.PreHash)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.IsProposer {
		n += 2
	}
	return n
}

func (m *WalEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.MsgType != 0 {
		n += 1 + sovChainedbft(uint64(m.MsgType))
	}
	if m.LastSnapshotIndex != 0 {
		n += 1 + sovChainedbft(uint64(m.LastSnapshotIndex))
	}
	return n
}

func sovChainedbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainedbft(x uint64) (n int) {
	return sovChainedbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QuorumCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewView = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Votes = append(m.Votes, &VoteData{})
			if err := m.Votes[len(m.Votes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qc == nil {
				m.Qc = &QuorumCert{}
			}
			if err := m.Qc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestQc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestQc == nil {
				m.HighestQc = &QuorumCert{}
			}
			if err := m.HighestQc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestTc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestTc == nil {
				m.HighestTc = &QuorumCert{}
			}
			if err := m.HighestTc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestTcLevel", wireType)
			}
			m.HighestTcLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestTcLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = append(m.Proposer[:0], dAtA[iNdEx:postIndex]...)
			if m.Proposer == nil {
				m.Proposer = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerIdx", wireType)
			}
			m.ProposerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifyQc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JustifyQc == nil {
				m.JustifyQc = &QuorumCert{}
			}
			if err := m.JustifyQc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposalData == nil {
				m.ProposalData = &ProposalData{}
			}
			if err := m.ProposalData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncInfo == nil {
				m.SyncInfo = &SyncInfo{}
			}
			if err := m.SyncInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewView = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &common.EndorsementEntry{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteData == nil {
				m.VoteData = &VoteData{}
			}
			if err := m.VoteData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncInfo == nil {
				m.SyncInfo = &SyncInfo{}
			}
			if err := m.SyncInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockFetchMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockFetchMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockFetchMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockId", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockId = append(m.BlockId[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockId == nil {
				m.BlockId = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBlocks", wireType)
			}
			m.NumBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqId", wireType)
			}
			m.ReqId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitBlock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitBlock = append(m.CommitBlock[:0], dAtA[iNdEx:postIndex]...)
			if m.CommitBlock == nil {
				m.CommitBlock = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LockedBLock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LockedBLock = append(m.LockedBLock[:0], dAtA[iNdEx:postIndex]...)
			if m.LockedBLock == nil {
				m.LockedBLock = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Qc == nil {
				m.Qc = &QuorumCert{}
			}
			if err := m.Qc.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockFetchRespMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockFetchRespMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockFetchRespMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BlockFetchStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockPair{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespId", wireType)
			}
			m.RespId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_ProposalMsg{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VoteMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_VoteMsg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFetchMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockFetchMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_BlockFetchMsg{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFetchRespMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockFetchRespMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_BlockFetchRespMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &ConsensusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignEntry == nil {
				m.SignEntry = &common.EndorsementEntry{}
			}
			if err := m.SignEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreHash = append(m.PreHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreHash == nil {
				m.PreHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProposer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProposer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WalEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WalEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WalEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &ConsensusMsg{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgType", wireType)
			}
			m.MsgType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgType |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSnapshotIndex", wireType)
			}
			m.LastSnapshotIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSnapshotIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainedbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainedbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainedbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainedbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainedbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainedbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainedbft = fmt.Errorf("proto: unexpected end of group")
)
